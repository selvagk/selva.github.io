(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three'), require('troika-core'), require('troika-three-utils'), require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', 'three', 'troika-core', 'troika-three-utils', 'react', 'prop-types'], factory) :
  (global = global || self, factory(global.troika_3d = {}, global.THREE, global.troika_core, global.troika_three_utils, global.React, global.PropTypes));
}(this, (function (exports, three, troikaCore, troikaThreeUtils, React, T) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;
  T = T && T.hasOwnProperty('default') ? T['default'] : T;

  var assign = troikaCore.utils.assign;
  var forOwn = troikaCore.utils.forOwn;
  var singletonVec3 = new three.Vector3();
  var singletonMat4 = new three.Matrix4();
  var singletonQuat = new three.Quaternion();
  var lookAtUp = new three.Vector3(0, 1, 0);
  var notifyWorldGetter = (function() {
    var obj = {
      callback: function(pos) {
        obj.value = pos;
      },
      value: null
    };
    return obj
  })();
  var removedEvent = {type: 'removed'};
  var singletonIntersects = [];

  function ascDistanceSort(a, b) {
    return a.distance - b.distance
  }

  function canObjectBeOrphaned(obj) {
    return obj.isRenderable === false && (
      !obj.children.length || obj.children.every(canObjectBeOrphaned)
    )
  }

  var _worldMatrixVersion = 0;
  var _geometrySphereVersion = 0;

  var Object3DFacade = /*@__PURE__*/(function (PointerEventTarget) {
    function Object3DFacade(parent, threeObject) {
      PointerEventTarget.call(this, parent);

      // We'll track matrix updates manually
      threeObject.matrixAutoUpdate = false;

      // Set bidirectional refs
      this.threeObject = threeObject;
      threeObject.$facade = this;

      // Subclasses may set isRenderable=false on the threeObject, to trigger some scene graph optimizations.
      // The first is to remove it from all layer masks to short-circuit WebGLRenderer.projectObject.
      var isRenderable = threeObject.isRenderable !== false;
      if (!isRenderable) {
        threeObject.layers.mask = 0;
      }

      // Add it as a child of the nearest parent threeObject, if one exists
      while (parent) {
        if (parent.isObject3DFacade) {
          this._parentObject3DFacade = parent; //reference to nearest Object3DFacade ancestor
          if (isRenderable) {
            this._addToThreeObjectTree();
          }
          break
        }
        parent = parent.parent;
      }

      this.notifyWorld('object3DAdded');
    }

    if ( PointerEventTarget ) Object3DFacade.__proto__ = PointerEventTarget;
    Object3DFacade.prototype = Object.create( PointerEventTarget && PointerEventTarget.prototype );
    Object3DFacade.prototype.constructor = Object3DFacade;

    Object3DFacade.prototype.afterUpdate = function afterUpdate () {
      // Apply lookAt+up as a final transform - applied as individual quaternion
      // properties so they can selectively trigger updates, be transitioned, etc.
      if (this.lookAt) {
        singletonVec3.copy(this.lookAt);
        lookAtUp.copy(this.up || three.Object3D.DefaultUp);
        singletonMat4.lookAt(this.threeObject.position, singletonVec3, lookAtUp);
        singletonQuat.setFromRotationMatrix(singletonMat4);
        this.quaternionX = singletonQuat.x;
        this.quaternionY = singletonQuat.y;
        this.quaternionZ = singletonQuat.z;
        this.quaternionW = singletonQuat.w;
      }

      // Update matrix and worldMatrix before processing children
      this.updateMatrices();
      this._checkBoundsChange();

      // If the world matrix was modified, and we won't be doing an update pass on child facades due
      // to `shouldUpdateChildren` optimization, we need to manually update their matrices to match.
      if (this._worldMatrixVersion > this._worldMatrixVersionAfterLastUpdate) {
        if (!this.shouldUpdateChildren()) {
          this.traverse(function (facade, rootFacade) {
            if (facade !== rootFacade && facade.updateMatrices) {
              facade.updateMatrices();
              facade._checkBoundsChange();
            }
          }, this);
        }
        this._worldMatrixVersionAfterLastUpdate = this._worldMatrixVersion;
      }

      // Process children
      PointerEventTarget.prototype.afterUpdate.call(this);

      // If any children were removed during the update, remove them from the threejs
      // object in a single batch; this avoids threejs's very expensive single-item remove.
      if (this._removeChildIds) {
        var threeObject = this.threeObject;
        var removeChildIds = this._removeChildIds;
        threeObject.children = threeObject.children.filter(function (child) {
          if (child.id in removeChildIds) {
            child.parent = null;
            child.dispatchEvent(removedEvent);
            return false
          }
          return true
        });

        // If that resulted in a non-renderable object having no renderable children,
        // queue it for removal it from the threejs object tree
        var parentObj3D = this._parentObject3DFacade;
        if (canObjectBeOrphaned(threeObject) && parentObj3D && parentObj3D.threeObject === threeObject.parent) {
          parentObj3D._queueRemoveChildObject3D(threeObject.id);
        }

        this._removeChildIds = null;
      }
    };

    /**
     * Update the underlying threeObject's `matrix` and `matrixWorld` to the current state if necessary.
     * This bypasses the `updateMatrix` and `updateMatrixWorld` methods of the threejs objects with a more
     * efficient approach that doesn't require traversing the entire tree prior to every render. This is possible
     * since we control the update lifecycle; as long as this is called from the `afterUpdate` lifecycle
     * method or later, it can be safely assumed that the world matrices of all ancestors have already been
     * similarly updated so the result should always be accurate.
     */
    Object3DFacade.prototype.updateMatrices = function updateMatrices () {
      var threeObj = this.threeObject;
      var parent3DFacade = this._parentObject3DFacade;
      var needsWorldMatrixUpdate;
      if (this._matrixChanged) {
        threeObj.matrix.compose(threeObj.position, threeObj.quaternion, threeObj.scale);
        this._matrixChanged = false;
        needsWorldMatrixUpdate = true;
      } else {
        needsWorldMatrixUpdate = parent3DFacade && parent3DFacade._worldMatrixVersion > this._worldMatrixVersion;
      }
      if (needsWorldMatrixUpdate) {
        if (parent3DFacade) {
          threeObj.matrixWorld.multiplyMatrices(parent3DFacade.threeObject.matrixWorld, threeObj.matrix);
        } else {
          threeObj.matrixWorld.copy(threeObj.matrix);
        }

        // If the threeObject has children that were manually added (not managed by facades), we'll need to update them too
        // TODO can we determine this state without a full loop that will likely return nothing?
        var threeKids = threeObj.children;
        for (var i = 0, len = threeKids.length; i < len; i++) {
          if (!threeKids[i].$facade) {
            threeKids[i].updateMatrixWorld(true);
          }
        }

        this.markWorldMatrixDirty();
      }
    };

    /**
     * If the `threeObject.matrixWorld` is modified manually instead of via the individual transformation
     * properties, you can call this to tell the facade its caches need to be recalculated.
     */
    Object3DFacade.prototype.markWorldMatrixDirty = function markWorldMatrixDirty () {
      this._worldMatrixVersion = ++_worldMatrixVersion;
      this._boundsChanged = true;
    };

    Object3DFacade.prototype._checkBoundsChange = function _checkBoundsChange () {
      var changed = this._boundsChanged;
      if (!changed) {
        var geomSphere = this._getGeometryBoundingSphere();
        if (geomSphere && geomSphere.version !== this._lastGeometrySphereVersion) {
          changed = true;
          this._lastGeometrySphereVersion = geomSphere.version;
        }
      }
      if (changed) {
        this.notifyWorld('object3DBoundsChanged');
        this._boundsChanged = false;
      }
    };

    /**
     * Get this object's current position in world space
     * @param {Vector3} vec3 - optional Vector3 object to populate with the position;
     *                  if not passed in a new one will be created.
     * @returns {Vector3}
     */
    Object3DFacade.prototype.getWorldPosition = function getWorldPosition (vec3) {
      if ( vec3 === void 0 ) vec3 = new three.Vector3();

      this.updateMatrices();
      vec3.setFromMatrixPosition(this.threeObject.matrixWorld);
      return vec3
    };

    /**
     * Get the current position vector of the world's camera.
     * @returns {Vector3}
     */
    Object3DFacade.prototype.getCameraPosition = function getCameraPosition () {
      notifyWorldGetter.value = null;
      this.notifyWorld('getCameraPosition', notifyWorldGetter);
      return notifyWorldGetter.value
    };

    /**
     * Get the facade object for the world's camera. Can be used to get to low-level info
     * about the camera such as its various matrices, but be careful not to make modifications
     * to the camera as that can lead to things getting out of sync.
     * @returns {Camera3DFacade}
     */
    Object3DFacade.prototype.getCameraFacade = function getCameraFacade () {
      notifyWorldGetter.value = null;
      this.notifyWorld('getCameraFacade', notifyWorldGetter);
      return notifyWorldGetter.value
    };

    /**
     * Calculate the distance in world units between this object's origin and the camera.
     * @returns {Number}
     */
    Object3DFacade.prototype.getCameraDistance = function getCameraDistance () {
      var cameraPos = this.getCameraPosition();
      var objectPos = this.getWorldPosition(singletonVec3);
      return cameraPos.distanceTo(objectPos)
    };

    /**
     * Get the current projected user space position for this object, or for a specific position
     * in its object space.
     * @returns {Vector3} x and y are in screen pixels, z is worldspace distance from camera. The
     *                    z may be negative, which means it is out of view behind the camera.
     */
    Object3DFacade.prototype.getProjectedPosition = function getProjectedPosition (x, y, z) {
      this.updateMatrices();
      notifyWorldGetter.value = null;
      notifyWorldGetter.worldPosition = singletonVec3.set(x || 0, y || 0, z || 0).applyMatrix4(this.threeObject.matrixWorld);
      this.notifyWorld('projectWorldPosition', notifyWorldGetter);
      return notifyWorldGetter.value
    };

    /**
     * Get the facade object for the world's scene.
     * @returns {Scene3DFacade}
     */
    Object3DFacade.prototype.getSceneFacade = function getSceneFacade () {
      notifyWorldGetter.value = null;
      this.notifyWorld('getSceneFacade', notifyWorldGetter);
      return notifyWorldGetter.value
    };

    /**
     * Return a {@link Sphere} encompassing the bounds of this object in worldspace, or `null` if
     * it has no physical bounds. This is used for optimized raycasting.
     *
     * The default implementation attempts to be as efficient as possible, only updating the sphere
     * when necessary, and assumes the threeObject has a geometry that accurately describes its bounds.
     * Override this method to provide custom bounds calculation logic, for example when additional meshes
     * need to be checked or a vertex shader manipulates the geometry; you'll probably also need to override
     * {@link #raycast} to match.
     *
     * TODO: this needs to be easier to override without having to reimplement large chunks of logic
     */
    Object3DFacade.prototype.getBoundingSphere = function getBoundingSphere () {
      // Get the geometry's current bounding sphere
      var geomSphere = this._getGeometryBoundingSphere();
      if (!geomSphere) { return null }

      // Ensure world matrix is up to date
      this.updateMatrices();

      // Lazily create our Sphere
      var sphere = this._boundingSphere;
      if (!sphere) {
        sphere = this._boundingSphere = new three.Sphere();
      }

      // If the geometry, the geometry's bounding sphere, or this object's world matrix changed,
      // update our bounding sphere to match them.
      if (sphere._geometrySphereVersion !== geomSphere.version || sphere._worldMatrixVersion !== this._worldMatrixVersion) {
        sphere.copy(geomSphere);
        sphere.applyMatrix4(this.threeObject.matrixWorld);
        sphere._worldMatrixVersion = this._worldMatrixVersion;
        sphere._geometrySphereVersion = geomSphere.version;
      }

      return sphere
    };

    /**
     * Ensure the object's geometry, if any, has an up-to-date bounding Sphere, and return that Sphere.
     * The returned Sphere will be assigned a unique `version` property when it is modified, which can
     * be used elsewhere for tracking changes.
     * @private
     */
    Object3DFacade.prototype._getGeometryBoundingSphere = function _getGeometryBoundingSphere () {
      var geometry = this.getGeometry();
      if (geometry) {
        var geomSphere = geometry.boundingSphere;
        var geomSphereChanged = false;
        if (geomSphere) {
          if (geometry.isBufferGeometry) {
            // For a BufferGeometry we can look at the `position` attribute's `version` (incremented
            // when the user sets `geom.needsUpdate = true`) to detect the need for bounds recalc
            var posAttr = geometry.attributes.position;
            if (posAttr && geomSphere._posAttrVersion !== posAttr.version) {
              geometry.computeBoundingSphere();
              geomSphere._posAttrVersion = posAttr.version;
              geomSphereChanged = true;
            }
          } else {
            // For a non-buffer Geometry (not recommended!) users will have to manually call
            // `geom.computeBoundingSphere()` after changing its vertices, and we'll do a brute force
            // check for changes to the sphere's properties
            if (!geometry._lastBoundingSphere || !geomSphere.equals(geometry._lastBoundingSphere)) {
              geometry._lastBoundingSphere = geomSphere.clone();
              geomSphereChanged = true;
            }
          }
        } else {
          geometry.computeBoundingSphere();
          geomSphere = geometry.boundingSphere;
          geomSphereChanged = true;
        }
        if (geomSphereChanged) {
          geomSphere.version = ++_geometrySphereVersion;
        }
        return geomSphere
      } else {
        return null
      }
    };

    /**
     * @protected Extension point for subclasses that don't use their threeObject's geometry, e.g. Instanceable
     */
    Object3DFacade.prototype.getGeometry = function getGeometry () {
      var obj = this.threeObject;
      return obj && obj.geometry
    };

    /**
     * Determine if this facade's threeObject intersects a Raycaster. Override this method to provide
     * custom raycasting logic, for example when additional meshes need to be checked or a vertex shader
     * manipulates the geometry; you'll probably also need to override {@link #getBoundingSphere} to match.
     *
     * The return value can be:
     *   - An array of hit objects for this facade, matching the format returned by `Raycaster.intersectObject`
     *   - `null`, if this facade has no hits
     */
    Object3DFacade.prototype.raycast = function raycast (raycaster) {
      return this.threeObject ? this._raycastObject(this.threeObject, raycaster) : null
    };

    /**
     * Custom optimized raycast that, unlike Raycaster.intersectObject(), avoids creating a
     * new array unless there are actually hits. It also supports the custom `raycastSide`
     * override property, hit on sides other than the material's configured `side`.
     * @protected
     */
    Object3DFacade.prototype._raycastObject = function _raycastObject (obj, raycaster) {
      if (obj.visible) {
        singletonIntersects.length = 0;
        var origSide = null;
        var raycastSide = this.raycastSide;
        if (raycastSide != null) {
          origSide = obj.material.side;
          obj.material.side = raycastSide;
        }
        obj.raycast(raycaster, singletonIntersects);
        if (origSide !== null) {
          obj.material.side = origSide;
        }
        if (singletonIntersects.length) {
          singletonIntersects.sort(ascDistanceSort);
          return singletonIntersects.slice()
        }
      }
      return null
    };

    Object3DFacade.prototype._addToThreeObjectTree = function _addToThreeObjectTree () {
      var parent = this._parentObject3DFacade;
      if (parent) {
        if (this.threeObject.parent !== parent.threeObject) {
          parent.threeObject.add(this.threeObject);
          parent._addToThreeObjectTree();
        }
      }
    };

    Object3DFacade.prototype._queueRemoveChildObject3D = function _queueRemoveChildObject3D (threeObjectId) {
      var removeChildIds = this._removeChildIds || (this._removeChildIds = Object.create(null));
      removeChildIds[threeObjectId] = true;
    };

    Object3DFacade.prototype.destructor = function destructor () {
      this.notifyWorld('object3DRemoved');
      var parentObj3D = this._parentObject3DFacade;
      if (parentObj3D) {
        parentObj3D._queueRemoveChildObject3D(this.threeObject.id);
      }
      delete this.threeObject;
      PointerEventTarget.prototype.destructor.call(this);
    };

    return Object3DFacade;
  }(troikaCore.PointerEventTarget));
  ['castShadow', 'receiveShadow', 'renderOrder', 'visible'].forEach(function (prop) {
    Object.defineProperty(Object3DFacade.prototype, prop, {
      get: function get() {
        return this.threeObject[prop]
      },
      set: function set(value) {
        this.threeObject[prop] = value;
      }
    });
  });

  /**
   * @property {null|number} raycastSide
   * Hook to force a different `side` than that of the material for mesh raycasting.
   * Should be set to `FrontSide`|`BackSide`|`DoubleSide`, or `null` to use the
   * material's side.
   */
  Object3DFacade.prototype.raycastSide = null;


  // Create flat property setters for individual position/scale/rotation properties
  forOwn({
    position: {
      x: 'x',
      y: 'y',
      z: 'z'
    },
    scale: {
      x: 'scaleX',
      y: 'scaleY',
      z: 'scaleZ'
    },
    rotation: {
      x: 'rotateX',
      y: 'rotateY',
      z: 'rotateZ',
      order: 'rotateOrder'
    },
    quaternion: {
      x: 'quaternionX',
      y: 'quaternionY',
      z: 'quaternionZ',
      w: 'quaternionW'
    }
  }, function (attrs, aspect) {
    forOwn(attrs, function (propName, attr) {
      // Compile functions to avoid runtime cost of aspect/attr evaluation
      Object.defineProperty(Object3DFacade.prototype, propName, {
        get: new Function(("return function " + propName + "$get() {\n  return this.threeObject." + aspect + "." + attr + "\n}"))(),
        set: new Function(("return function " + propName + "$set(value) {\n  //let obj = this.threeObject." + aspect + "\n  if (this.threeObject." + aspect + "." + attr + " !== value) {\n    this.threeObject." + aspect + "." + attr + " = value\n    if (!this._matrixChanged) {\n      this._matrixChanged = true\n    }\n  }\n}"))()
      });
    });
  });

  // ...and a special shortcut for uniform scale
  Object.defineProperty(Object3DFacade.prototype, 'scale', {
    get: function get() {
      // can't guarantee scale was already uniform, so just use scaleX arbitrarily
      return this.threeObject.scale.x
    },
    set: function set(value) {
      var scaleObj = this.threeObject.scale;
      if (value !== scaleObj.x || value !== scaleObj.y || value !== scaleObj.z) {
        scaleObj.x = scaleObj.y = scaleObj.z = value;
        if (!this._matrixChanged) {
          this._matrixChanged = true;
        }
      }
    }
  });


  Object.defineProperty(Object3DFacade.prototype, 'isObject3DFacade', {value: true});

  // Predefine shape to facilitate JS engine optimization
  assign(Object3DFacade.prototype, {
    lookAt: null,
    threeObject: null,
    _parentObject3DFacade: null,
    _removeChildIds: null,
    _matrixChanged: true,
    _worldMatrixVersion: -1,
    _worldMatrixVersionAfterLastUpdate: -1,
    _boundingSphereChanged: false
  });

  // Define onBeforeRender/onAfterRender event handler properties
  troikaCore.Facade.defineEventProperty(Object3DFacade, 'onBeforeRender', 'beforerender');
  troikaCore.Facade.defineEventProperty(Object3DFacade, 'onAfterRender', 'afterrender');

  var noop = function() {};
  var tempRaycaster = new three.Raycaster();
  var tempVec2 = new three.Vector2();

  var _projectionMatrixVersion = 0;

  function createCameraFacade(threeJsCameraClass, projectionProps, otherProps) {
    var Camera3DFacade = /*@__PURE__*/(function (Object3DFacade) {
      function Camera3DFacade(parent) {
        var camera = new threeJsCameraClass();
        Object3DFacade.call(this, parent, camera);
        this._projectionChanged = false;
        this._frustum = new three.Frustum();

        // Forcibly prevent updateMatrixWorld from doing anything when called; the renderer
        // likes to call this even though matrixAutoUpdate=false which can sometimes clobber
        // our optimized `updateMatrices` handling and any custom adjustments it may make.
        // TODO consider doing this at the Object3DFacade level?
        camera.updateMatrixWorld = noop;
      }

      if ( Object3DFacade ) Camera3DFacade.__proto__ = Object3DFacade;
      Camera3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
      Camera3DFacade.prototype.constructor = Camera3DFacade;

      Camera3DFacade.prototype.updateMatrices = function updateMatrices () {
        var camObj = this.threeObject;

        // Projection changes require a projection matrix rebuild - see setters below
        if (this._projectionChanged) {
          camObj.updateProjectionMatrix();
          this._projectionChanged = false;
          this._projectionMatrixVersion = _projectionMatrixVersion++;
        }

        // If changing the world matrix, also update its inverse
        var matrixVersionBeforeUpdate = this._worldMatrixVersion;
        Object3DFacade.prototype.updateMatrices.call(this);
        if (matrixVersionBeforeUpdate !== this._worldMatrixVersion) {
          camObj.matrixWorldInverse.getInverse(camObj.matrixWorld);
        }
      };

      /**
       * Utility method that returns a Frustum object which is initialized to match this camera's
       * current state. This can be used for example to optimize updates to the Facade tree by
       * avoiding work for objects that fall outside the camera's view.
       *
       * You can access this by calling `this.getCameraFacade().getFrustum()` from any Object3DFacade's
       * `afterUpdate` lifecycle method or later.
       *
       * Be careful that this Frustum does not get modified after it is requested, as it is cached for
       * the lifetime of the camera's current world matrix and modifiying it would result in bad state
       * for other code requesting it within that lifetime.
       *
       * @return {Frustum}
       */
      Camera3DFacade.prototype.getFrustum = function getFrustum () {
        this.updateMatrices();
        var frustum = this._frustum;
        var ref = this;
        var _worldMatrixVersion = ref._worldMatrixVersion;
        var _projectionMatrixVersion = ref._projectionMatrixVersion;
        if (frustum._lastWorldMatrixVersion !== _worldMatrixVersion || frustum._lastProjMatrixVersion !== _projectionMatrixVersion) {
          var camObj = this.threeObject;
          var matrix = new three.Matrix4().multiplyMatrices(camObj.projectionMatrix, camObj.matrixWorldInverse);
          frustum.setFromMatrix(matrix);
          frustum._lastWorldMatrixVersion = _worldMatrixVersion;
          frustum._lastProjMatrixVersion = _projectionMatrixVersion;
        }
        return frustum
      };

      /**
       * Given a set of camera projection coordinates (u,v in the range [-1, 1]), return a `Ray`
       * representing that line of sight in worldspace.
       * @param {number} u
       * @param {number} v
       * @return Ray
       */
      Camera3DFacade.prototype.getRayAtProjectedCoords = function getRayAtProjectedCoords (u, v) {
        // By default we use the builtin Raycaster functionality, but this can be overridden
        var ray = tempRaycaster.ray = new three.Ray();
        tempRaycaster.setFromCamera(tempVec2.set(u, v), this.threeObject);
        return ray
      };

      return Camera3DFacade;
    }(Object3DFacade));

    // Setters for properties which require a matrix update
    function defineProp(prop, affectsProjection) {
      Object.defineProperty(Camera3DFacade.prototype, prop, {
        set: function set(val) {
          if (val !== this.threeObject[prop]) {
            this.threeObject[prop] = val;
            if (affectsProjection) { this._projectionChanged = true; }
          }
        },
        get: function get() {
          return this.threeObject[prop]
        }
      });
    }

    projectionProps.forEach(function (prop) {
      defineProp(prop, true);
    });

    if (otherProps) {
      otherProps.forEach(function (prop) {
        defineProp(prop, false);
      });
    }

    return Camera3DFacade
  }


  var PerspectiveCamera3DFacade = createCameraFacade(three.PerspectiveCamera, ['fov', 'aspect', 'near', 'far'], ['focus', 'filmGauge', 'filmOffset']);
  var OrthographicCamera3DFacade = createCameraFacade(three.OrthographicCamera, ['left', 'right', 'top', 'bottom', 'near', 'far']);

  var Group3DFacade = /*@__PURE__*/(function (Object3DFacade) {
    function Group3DFacade(parent) {
      var group = new three.Group();
      group.isRenderable = false; //trigger optimizations
      Object3DFacade.call(this, parent, group);
    }

    if ( Object3DFacade ) Group3DFacade.__proto__ = Object3DFacade;
    Group3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
    Group3DFacade.prototype.constructor = Group3DFacade;

    return Group3DFacade;
  }(Object3DFacade));

  /**
   * Defines a snippet of HTML content that will be positioned to line up with the object's
   * xyz as projected by the scene's camera. This is a convenient way to display tooltips,
   * labels, and pieces of UI that follow a given object around.
   */
  var HtmlOverlay3DFacade = /*@__PURE__*/(function (Object3DFacade) {
    function HtmlOverlay3DFacade(parent) {
      var obj = new three.Object3D();
      obj.isRenderable = false; //trigger optimizations
      Object3DFacade.call(this, parent, obj);

      /**
       * Defines the HTML content to be rendered. The type/format of this value is dependent
       * on the wrapping implementation; for example the Canvas3D.jsx React-based wrapper will
       * expect a React element descriptor, while other wrappers might expect a HTML string.
       *
       * When using the React-based wrapper, the rendered React component will not be updated
       * when the overlay is repositioned, unless (a) the `html` element descriptor changes, or
       * (b) that element descriptor has a `shouldUpdateOnMove` prop.
       */
      this.html = null;

      /**
       * If set to true, the overlay's x/y position on screen will not be rounded to whole-pixel
       * values. This can give more accurate alignment at the expense of fuzzy lines and text.
       */
      this.exact = false;

      this.notifyWorld('addHtmlOverlay', this);
    }

    if ( Object3DFacade ) HtmlOverlay3DFacade.__proto__ = Object3DFacade;
    HtmlOverlay3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
    HtmlOverlay3DFacade.prototype.constructor = HtmlOverlay3DFacade;

    HtmlOverlay3DFacade.prototype.destructor = function destructor () {
      this.notifyWorld('removeHtmlOverlay', this);
      Object3DFacade.prototype.destructor.call(this);
    };

    return HtmlOverlay3DFacade;
  }(Object3DFacade));

  //import {ShadowMapViewer} from 'three/examples/jsm/utils/ShadowMapViewer.js'


  // Common superclass with setters for all possible light properties
  var Light3DFacade = /*@__PURE__*/(function (Object3DFacade) {
    function Light3DFacade () {
      Object3DFacade.apply(this, arguments);
    }

    if ( Object3DFacade ) Light3DFacade.__proto__ = Object3DFacade;
    Light3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
    Light3DFacade.prototype.constructor = Light3DFacade;

    var prototypeAccessors = { color: { configurable: true },shadow: { configurable: true } };

    prototypeAccessors.color.set = function (c) {
      this.threeObject.color.set(c);
    };

    // Shadow map configurable by deep object copy:
    prototypeAccessors.shadow.get = function () {
      return this.threeObject.shadow
    };
    prototypeAccessors.shadow.set = function (val) {
      troikaCore.utils.assignDeep(this.threeObject.shadow, val);
    };

    Object.defineProperties( Light3DFacade.prototype, prototypeAccessors );

    return Light3DFacade;
  }(Object3DFacade));
  // Setters for simple properties to be copied
  ['intensity', 'distance', 'angle', 'penumbra', 'decay', 'castShadow'].forEach(function (propName) {
    Object.defineProperty(Light3DFacade.prototype, propName, {
      get: function get() {
        return this.threeObject[propName]
      },
      set: function set(value) {
        this.threeObject[propName] = value;
      }
    });
  });


  function createLightFacade(ThreeJsLightClass) {
    return /*@__PURE__*/(function (Light3DFacade) {
      function anonymous(parent) {
        Light3DFacade.call(this, parent, new ThreeJsLightClass());
        // const helper = new ShadowMapViewer(this.threeObject)
        // this.addEventListener('afterrender', (renderer) => {
        //   helper.render(renderer)
        // })
      }

      if ( Light3DFacade ) anonymous.__proto__ = Light3DFacade;
      anonymous.prototype = Object.create( Light3DFacade && Light3DFacade.prototype );
      anonymous.prototype.constructor = anonymous;

      return anonymous;
    }(Light3DFacade))
  }

  var AmbientLight3DFacade = createLightFacade(three.AmbientLight);
  var DirectionalLight3DFacade = createLightFacade(three.DirectionalLight);
  var SpotLight3DFacade = createLightFacade(three.SpotLight);
  var PointLight3DFacade = createLightFacade(three.PointLight);

  var inverseFunction = "\n#if __VERSION__ < 300\n// matrix inversion utility for pre-ES3 - credit https://github.com/stackgl/glsl-inverse\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(\n    b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n    b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n    b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)\n  ) / det;\n}\n#endif\n";

  var modelMatrixRowAttrs = "\nattribute vec4 troika_modelMatrixRow0;\nattribute vec4 troika_modelMatrixRow1;\nattribute vec4 troika_modelMatrixRow2;\n";

  var modelMatrixVarAssignment = "\nmat4 troika_modelMatrix = mat4(\n  %0.x, %1.x, %2.x, 0.0,\n  %0.y, %1.y, %2.y, 0.0,\n  %0.z, %1.z, %2.z, 0.0,\n  %0.w, %1.w, %2.w, 1.0\n);\n".replace(/%/g, 'troika_modelMatrixRow');

  var modelViewMatrixVarAssignment = "\nmat4 troika_modelViewMatrix = viewMatrix * troika_modelMatrix;\n";

  var normalMatrixVarAssignment = "\nmat3 troika_normalMatrix = transposeMat3(inverse(mat3(troika_modelViewMatrix)));\n";


  var modelMatrixRefRE = /\bmodelMatrix\b/g;
  var modelViewMatrixRefRE = /\bmodelViewMatrix\b/g;
  var normalMatrixRefRE = /\bnormalMatrix\b/g;
  var precededByUniformRE = /\buniform\s+(int|float|vec[234])\s+$/;
  var attrRefReplacer = function (name, index, str) { return precededByUniformRE.test(str.substr(0, index)) ? name : ("troika_" + name); };
  var varyingRefReplacer = function (name, index, str) { return precededByUniformRE.test(str.substr(0, index)) ? name : ("troika_vary_" + name); };




  /**
   * Transform the given vertex and fragment shader pair so they accept instancing
   * attributes for the builtin matrix uniforms as well as any other uniforms that
   * have been declared as instanceable.
   */
  function upgradeShaders(vertexShader, fragmentShader, instanceUniforms) {
    if ( instanceUniforms === void 0 ) instanceUniforms=[];

    // Pre-expand includes
    vertexShader = troikaThreeUtils.expandShaderIncludes(vertexShader);
    fragmentShader = troikaThreeUtils.expandShaderIncludes(fragmentShader);

    // See what gets used
    var usesModelMatrix = modelMatrixRefRE.test(vertexShader);
    var usesModelViewMatrix = modelViewMatrixRefRE.test(vertexShader);
    var usesNormalMatrix = normalMatrixRefRE.test(vertexShader);

    // Find what uniforms are declared in which shader and their types
    var vertexUniforms = troikaThreeUtils.getShaderUniformTypes(vertexShader);
    var fragmentUniforms = troikaThreeUtils.getShaderUniformTypes(fragmentShader);

    var vertexDeclarations = [modelMatrixRowAttrs];
    var vertexAssignments = [];
    var fragmentDeclarations = [];

    // Add variable assignments for, and rewrite references to, builtin matrices
    if (usesModelMatrix || usesModelViewMatrix || usesNormalMatrix) {
      vertexShader = vertexShader.replace(modelMatrixRefRE, attrRefReplacer);
      vertexAssignments.push(modelMatrixVarAssignment);
    }
    if (usesModelViewMatrix || usesNormalMatrix) {
      vertexShader = vertexShader.replace(modelViewMatrixRefRE, attrRefReplacer);
      vertexAssignments.push(modelViewMatrixVarAssignment);
    }
    if (usesNormalMatrix) {
      vertexShader = vertexShader.replace(normalMatrixRefRE, attrRefReplacer);
      vertexAssignments.push(normalMatrixVarAssignment);
      // Add the inverse() glsl polyfill if there isn't already one defined
      if (!/\binverse\s*\(/.test(vertexShader)) {
        vertexDeclarations.push(inverseFunction);
      }
    }

    // Add attributes and varyings for, and rewrite references to, instanceUniforms
    instanceUniforms.forEach(function (name) {
      var vertType = vertexUniforms[name];
      var fragType = fragmentUniforms[name];
      if (vertType || fragType) {
        var finder = new RegExp(("\\b" + name + "\\b"), 'g');
        vertexDeclarations.push(("attribute " + (vertType || fragType) + " troika_" + name + ";"));
        if (vertType) {
          vertexShader = vertexShader.replace(finder, attrRefReplacer);
        }
        if (fragType) {
          fragmentShader = fragmentShader.replace(finder, varyingRefReplacer);
          var varyingDecl = "varying " + fragType + " troika_vary_" + name + ";";
          vertexDeclarations.push(varyingDecl);
          fragmentDeclarations.push(varyingDecl);
          vertexAssignments.push(("troika_vary_" + name + " = troika_" + name + ";"));
        }
      }
    });

    // Inject vertex shader declarations and assignments
    vertexShader = vertexShader.replace(troikaThreeUtils.voidMainRegExp, ("\n" + (vertexDeclarations.join('\n')) + "\n$&\n" + (vertexAssignments.join('\n')) + "\n"));

    // Inject fragment shader declarations
    if (fragmentDeclarations.length) {
      fragmentShader = fragmentShader.replace(troikaThreeUtils.voidMainRegExp, ("\n" + (fragmentDeclarations.join('\n')) + "\n$&\n    "));
    }

    return {vertexShader: vertexShader, fragmentShader: fragmentShader}
  }

  var assign$1 = troikaCore.utils.assign;
  var assignIf = troikaCore.utils.assignIf;

  var INSTANCE_BATCH_SIZE = 1024; //TODO make this an option?
  var DYNAMIC_DRAW = 0x88E8; //can't import DynamicDrawUsage from three without breaking older versions

  /**
   * An InstancingManager handles aggregating all Instanceable3DFacade descendants into
   * instancing batches. For each batch it creates a clone of the instancedThreeObject,
   * populates a pooled InstancedBufferGeometry with buffer attributes holding the world
   * matrices of all the batch's instances, and temporarily inserts that into the
   * scene to be rendered.
   *
   * As an additional "turbo" optimization, the instancing batch objects/geometries will be
   * reused untouched between rendering frames if none of the managed Instanceable3DFacade
   * objects have changed in a way that would affect the batches or world matrix attributes.
   *
   * There is a global InstancingManager automatically added to the main scene, and it does
   * nothing if there are no Instanceable3DFacades in the scene, so in most cases you should
   * not need to touch this yourself. But it is also possible to insert additional
   * InstancingManager facades further down in the scene if you wish to control the scope
   * of instancing, e.g. to increase the likelihood of the aforementioned "turbo" optimization
   * kicking in.
   *
   * Also see InstancingShaderUpgrades, which modifies material shaders so they accept the matrix
   * and custom uniform values coming in as attributes. This allows built-in materials as well
   * as custom shaders to work with instancing without manual modification.
   */
  var InstancingManager = /*@__PURE__*/(function (Group3DFacade) {
    function InstancingManager(parent) {
      Group3DFacade.call(this, parent);
      this._instanceables = Object.create(null);
      this._batchGeometryPool = new BatchGeometryPool();
      this._needsRebatch = true;
      this.addEventListener('beforerender', this._setupBatchObjects.bind(this));
      this.addEventListener('afterrender', this._teardownBatchObjects.bind(this));
    }

    if ( Group3DFacade ) InstancingManager.__proto__ = Group3DFacade;
    InstancingManager.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
    InstancingManager.prototype.constructor = InstancingManager;

    InstancingManager.prototype.onNotifyWorld = function onNotifyWorld (source, message, data) {
      var handler = this._notifyWorldHandlers[message];
      if (handler) {
        handler.call(this, source, data);
      } else if (this.parent) {
        this.parent.onNotifyWorld(source, message, data);
      }
    };

    InstancingManager.prototype._setupBatchObjects = function _setupBatchObjects (renderer, scene, camera) {
      var instanceables = this._instanceables;
      var batchObjectsByKey = this._batchObjectsByKey;
      var needsRebatch = this._needsRebatch;

      if (!needsRebatch) {
        // We'll already know about most types of changes (instanceable addition/removal, instancedThreeObject
        // changes, matrix changes) but if any of the instancedThreeObjects changed their geometry or material
        // internally we'll need to detect that here and deoptimize.
        for (var key in batchObjectsByKey) {
          var batchObj = batchObjectsByKey[key][0];
          if (this._getBatchKey(batchObj.$troikaBatchBaseObj) !== key) {
            needsRebatch = true;
            break
          }
        }
      }

      if (needsRebatch) {
        batchObjectsByKey = this._batchObjectsByKey = Object.create(null);
        var geometryPool = this._batchGeometryPool;
        for (var facadeId in instanceables) {
          var facade = instanceables[facadeId];
          var instanceObject = facade.threeObject;
          var protoObject = facade.instancedThreeObject;

          if (protoObject && instanceObject.visible) {
            // Find or create the batch object for this facade's instancedThreeObject
            var batchKey = this._getBatchKey(protoObject);
            var instanceUniforms = protoObject.material.instanceUniforms;
            var batchObjects = batchObjectsByKey[batchKey] || (batchObjectsByKey[batchKey] = []);
            var batchObject = batchObjects[batchObjects.length - 1];
            var batchGeometry = batchObject && batchObject.geometry;
            if (!batchGeometry || batchGeometry.maxInstancedCount === INSTANCE_BATCH_SIZE) {
              batchObject = this._getBatchObject(protoObject);
              batchGeometry = batchObject.geometry;
              var attrs = batchGeometry._instanceAttrs.matrix;
              for (var row = 0; row < 3; row++) {
                attrs[row].version++;
              }
              if (instanceUniforms) {
                attrs = batchGeometry._instanceAttrs.uniforms;
                for (var i = instanceUniforms.length; i--;) {
                  attrs[instanceUniforms[i]].version++;
                }
              }
              batchObjects.push(batchObject);
            }

            // Put the instance's world matrix into the batch geometry's instancing attributes
            var attrOffset = batchGeometry.maxInstancedCount++;
            var attrs$1 = batchGeometry._instanceAttrs.matrix;
            var elements = instanceObject.matrixWorld.elements; //column order
            attrs$1[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]);
            attrs$1[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]);
            attrs$1[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]);

            // Put the instance's values for instanceUniforms into the corresponding attributes
            if (instanceUniforms) {
              attrs$1 = batchGeometry._instanceAttrs.uniforms;
              for (var i$1 = instanceUniforms.length; i$1--;) {
                var uniform = instanceUniforms[i$1];
                var attr = attrs$1[uniform];
                var facadeUniforms = facade._instanceUniforms;
                var value = facadeUniforms && uniform in facadeUniforms ? facadeUniforms[uniform] : troikaThreeUtils.getShadersForMaterial(protoObject.material).uniforms[uniform].value; //TODO clean up
                setAttributeValue(attr, attrOffset, value);
              }
            }

            // Save pointers for possible reuse next frame
            facade._instancingBatchObject = batchObject;
            facade._instancingBatchAttrOffset = attrOffset;
          } else {
            facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
          }
        }

        // Dispose any old batch geometries that were unused during this render pass
        // TODO should this be delayed any to prevent thrashing?
        geometryPool.disposeUnused();
      }

      // Add the batch objects to the scene
      var batchCount = 0;
      var batchGrpCount = 0;
      var instanceCount = 0;
      for (var id in batchObjectsByKey) {
        var batchObjects$1 = batchObjectsByKey[id];
        scene.children.push.apply(scene.children, batchObjects$1);

        // increment stats
        batchGrpCount++;
        for (var i$2 = batchObjects$1.length; i$2--;) {
          batchCount++;
          instanceCount += batchObjects$1[i$2].geometry.maxInstancedCount;
        }
      }

      this.notifyWorld('statsUpdate', {
        'Instancing Batch Groups': batchGrpCount,
        'Instancing Batches': batchCount,
        'Instanced Objects': instanceCount
      });

      this._needsRebatch = false;
    };

    InstancingManager.prototype._onInstanceAdded = function _onInstanceAdded (facade) {
      this._instanceables[facade.$facadeId] = facade;
      this._needsRebatch = true;
    };

    InstancingManager.prototype._onInstanceRemoved = function _onInstanceRemoved (facade) {
      delete this._instanceables[facade.$facadeId];
      this._needsRebatch = true;
    };

    InstancingManager.prototype._onInstanceChanged = function _onInstanceChanged (facade) {
      this._needsRebatch = true;
    };

    InstancingManager.prototype._onInstanceMatrixChanged = function _onInstanceMatrixChanged (facade) {
      // If a single instance's matrix changed and the batches are still otherwise valid, avoid a
      // full rebatch by updating just this instance's values in the matrix attributes directly.
      if (!this._needsRebatch) {
        var protoObject = facade.instancedThreeObject;
        var batchObject = facade._instancingBatchObject;
        var attrOffset = facade._instancingBatchAttrOffset;
        if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject)) {
          var attrs = batchObject.geometry._instanceAttrs.matrix;
          var elements = facade.threeObject.matrixWorld.elements;
          attrs[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]).version++;
          attrs[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]).version++;
          attrs[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]).version++;
        } else {
          // Fallback just in case something didn't line up above - clear pointers and trigger rebatch
          facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
          this._needsRebatch = true;
        }
      }
    };

    InstancingManager.prototype._onInstanceUniformChanged = function _onInstanceUniformChanged (facade, uniformName) {
      if (!this._needsRebatch) {
        var protoObject = facade.instancedThreeObject;
        var batchObject = facade._instancingBatchObject;
        if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject)) {
          var attr = batchObject.geometry._instanceAttrs.uniforms[uniformName];
          setAttributeValue(attr, facade._instancingBatchAttrOffset, facade._instanceUniforms[uniformName]);
          attr.version++; //skip setter
        } else {
          // Fallback just in case something didn't line up above - clear pointers and trigger rebatch
          facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
          this._needsRebatch = true;
        }
      }
    };

    InstancingManager.prototype._getBatchKey = function _getBatchKey (object) {
      var cache = this._batchKeysCache || (this._batchKeysCache = Object.create(null)); //cache results for duration of this frame
      var key = cache && cache[object.id];
      if (!key) {
        var mat = object.material;
        var shaders = troikaThreeUtils.getShadersForMaterial(mat);
        var uniforms = mat.instanceUniforms;
        key = (object.geometry.id) + "|" + (mat.id) + "|" + (shaders.vertexShader) + "|" + (shaders.fragmentShader) + "|" + (uniforms ? uniforms.sort().join(',') : '');
        cache[object.id] = key;
      }
      return key
    };

    InstancingManager.prototype._getInstanceUniformsTypes = function _getInstanceUniformsTypes (material) {
      var cache = this._uniformTypesCache || (this._uniformTypesCache = Object.create(null)); //cache results for duration of this frame
      var result = cache[material.id];
      if (!result) {
        result = cache[material.id] = Object.create(null);
        var instanceUniforms = material.instanceUniforms;
        if (instanceUniforms && instanceUniforms.length) {
          var ref = troikaThreeUtils.getShadersForMaterial(material);
          var vertexShader = ref.vertexShader;
          var fragmentShader = ref.fragmentShader;
          var allTypes = assign$1(
            troikaThreeUtils.getShaderUniformTypes(troikaThreeUtils.expandShaderIncludes(vertexShader)),
            troikaThreeUtils.getShaderUniformTypes(troikaThreeUtils.expandShaderIncludes(fragmentShader))
          ); //TODO handle type mismatches?
          for (var i = instanceUniforms.length; i--;) {
            var uniform = instanceUniforms[i];
            if (allTypes[uniform]) {
              result[uniform] = allTypes[uniform];
            }
          }
        }
      }
      return result
    };

    InstancingManager.prototype._getBatchObject = function _getBatchObject (instancedObject) {
      var obj;

      var geometry = instancedObject.geometry;
      var material = instancedObject.material;

      // Upgrade the geometry to an instanced one
      if (!geometry.isBufferGeometry) {
        throw new Error('Instanceable proto object must use a BufferGeometry')
      }
      var batchKey = this._getBatchKey(instancedObject);
      var uniformsTypes = this._getInstanceUniformsTypes(material);
      var batchGeometry = this._batchGeometryPool.borrow(batchKey, geometry, uniformsTypes);
      batchGeometry.maxInstancedCount = 0;

      // Upgrade the material to one with the shader modifications and defines to trigger instancing
      var batchMaterial = Object.create(material);
      var instUniforms = material.instanceUniforms || [];
      instUniforms.sort();
      batchMaterial.defines = assignIf(( obj = {}, obj[("TROIKA_INSTANCED_" + (instUniforms.join('_')))] = '', obj ), batchMaterial.defines);
      batchMaterial.onBeforeCompile = function(shaderInfo) {
        // Upgrade the material's shaders to support instanced matrices and other uniforms
        // This will be called on program change even after first compile, so cache after first run
        var upgraded = material.$troikaUpgraded;
        var upgradeKey = (shaderInfo.vertexShader) + "|" + (shaderInfo.fragmentShader) + "|" + (instUniforms.join(','));
        if (!upgraded || upgraded.upgradeKey !== upgradeKey) {
          upgraded = material.$troikaUpgraded = upgradeShaders(shaderInfo.vertexShader, shaderInfo.fragmentShader, instUniforms);
          upgraded.upgradeKey = upgradeKey;
        }
        assign$1(shaderInfo, upgraded);
      };

      // Create a new mesh object to hold it all
      var shadowMaterial = null;
      var batchObject = Object.create(instancedObject, {
        // Lazy getters for shadow materials:
        customDepthMaterial: {
          get: function get() { return shadowMaterial = getBatchDepthMaterial() }
        },
        customDistanceMaterial: {
          get: function get() { return shadowMaterial = getBatchDistanceMaterial() }
        },
        // Hack to update viewMatrix for each face of the distance cube - see explanation
        // in getBatchDistanceMaterial() comments below. Would be cleaner to use an onBeforeRender
        // hook but that isn't called during shadowmap rendering.
        modelViewMatrix: {
          value: function() {
            var modelViewMatrix = new three.Matrix4();
            modelViewMatrix.multiplyMatrices = function(viewMatrix, matrixWorld) {
              three.Matrix4.prototype.multiplyMatrices.call(this, viewMatrix, matrixWorld);
              if (shadowMaterial && shadowMaterial._updateViewMatrix) {
                shadowMaterial._updateViewMatrix(viewMatrix);
              }
            };
            return modelViewMatrix
          }()
        }
      });
      batchObject.$troikaBatchBaseObj = instancedObject;
      batchObject.$troikaInstancingManager = this;
      batchObject.visible = true;
      batchObject.frustumCulled = false;
      batchObject.geometry = batchGeometry;
      batchObject.material = batchMaterial;
      // NOTE other props are inherited so don't need to copy them
      return batchObject
    };
    
    InstancingManager.prototype._teardownBatchObjects = function _teardownBatchObjects (renderer, scene, camera) {
      var this$1 = this;

      // Release geometries to the pool for next time
      this._batchGeometryPool.releaseAll();

      // Clear caches from this render frame
      this._batchKeysCache = null;
      this._uniformTypesCache = null;

      // Remove batch objects from scene
      scene.children = scene.children.filter(function (obj) { return obj.$troikaInstancingManager !== this$1; });
    };

    InstancingManager.prototype.destructor = function destructor () {
      var pool = this._batchGeometryPool;
      pool.releaseAll();
      pool.disposeUnused();
      Group3DFacade.prototype.destructor.call(this);
    };

    return InstancingManager;
  }(Group3DFacade));


  /**
   * Pool for the instancing batch geometries
   */
  var BatchGeometryPool = function BatchGeometryPool() {
    this._poolsByKey = Object.create(null);
  };

  BatchGeometryPool.prototype.borrow = function borrow (key, baseGeometry, uniformsTypes) {
    var poolsByKey = this._poolsByKey;
    var pool = poolsByKey[key] || (poolsByKey[key] = {geometries: [], firstFree: 0});
    var batchGeometry = pool.geometries[pool.firstFree++];

    if (!batchGeometry) {
      batchGeometry = new three.InstancedBufferGeometry();
      assign$1(batchGeometry, baseGeometry);
      batchGeometry.attributes = assign$1({}, baseGeometry.attributes);
      var instanceAttrs = batchGeometry._instanceAttrs = {matrix: [], uniforms: Object.create(null)}; //separate collections for quicker lookup

      // Create instancing attributes for the modelMatrix's rows
      for (var row = 0; row < 3; row++) {
        var attr = new three.InstancedBufferAttribute(new Float32Array(INSTANCE_BATCH_SIZE * 4), 4);
        if (attr.setUsage) {
          attr.setUsage(DYNAMIC_DRAW);
        } else {
          attr.dynamic = true;
        }
        batchGeometry.attributes[("troika_modelMatrixRow" + row)] = attr;
        instanceAttrs.matrix[row] = attr;
      }

      // Create instancing attributes for the instanceUniforms
      for (var name in uniformsTypes) {
        var type = uniformsTypes[name];
        var itemSize = ATTR_ITEM_SIZES[type];
        var ArrayType = type === 'int' ? Uint32Array : Float32Array;
        var attr$1 = new three.InstancedBufferAttribute(new ArrayType(INSTANCE_BATCH_SIZE * itemSize), itemSize);
        if (attr$1.setUsage) {
          attr$1.setUsage(DYNAMIC_DRAW);
        } else {
          attr$1.dynamic = true;
        }
        batchGeometry.attributes[("troika_" + name)] = attr$1;
        instanceAttrs.uniforms[name] = attr$1;
      }

      pool.geometries.push(batchGeometry);
    }

    return batchGeometry
  };

  BatchGeometryPool.prototype.releaseAll = function releaseAll () {
    var pools = this._poolsByKey;
    if (pools) {
      for (var key in pools) {
        pools[key].firstFree = 0;
      }
    }
  };

  BatchGeometryPool.prototype.disposeUnused = function disposeUnused () {
    var pools = this._poolsByKey;
    if (pools) {
      for (var key in pools) {
        var ref = pools[key];
          var firstFree = ref.firstFree;
          var geometries = ref.geometries;
        for (var i = firstFree, len = geometries.length; i < len; i++) {
          // Only allow the instancing attributes to be disposed; those copied from the
          // original geometry will be up to the author to dispose of properly
          var attrs = geometries[i].attributes;
          for (var attrName in attrs) {
            if (attrs.hasOwnProperty(attrName) && attrName.indexOf('troika_') !== 0) {
              delete attrs[attrName];
            }
          }
          try {
            // can throw if it's already been disposed or hasn't yet been rendered
            geometries[i].dispose();
          } catch(e) {}
          geometries[i]._instanceAttrs = null;
        }
        geometries.length = firstFree;
      }
    }
  };


  var proto = InstancingManager.prototype;
  proto._notifyWorldHandlers = {
    instanceableAdded: proto._onInstanceAdded,
    instanceableRemoved: proto._onInstanceRemoved,
    instanceableChanged: proto._onInstanceChanged,
    instanceableMatrixChanged: proto._onInstanceMatrixChanged,
    instanceableUniformChanged: proto._onInstanceUniformChanged
  };



  var ATTR_ITEM_SIZES = {
    'int': 1,
    'float': 1,
    'vec2': 2,
    'vec3': 3,
    'vec4': 4
  };


  function setAttributeValue(attr, offset, value) {
    var size = attr.itemSize;
    if (size === 1) {
      attr.setX(offset, value);
    }
    else if (size === 2) {
      attr.setXY(offset, value.x, value.y);
    }
    else if (size === 3) {
      if (value.isColor) {
        attr.setXYZ(offset, value.r, value.g, value.b);
      } else {
        attr.setXYZ(offset, value.x, value.y, value.z);
      }
    } else if (size === 4) {
      attr.setXYZW(offset, value.x, value.y, value.z, value.w);
    }
  }


  var getBatchDepthMaterial = function() {
    // We have to use a ShaderMaterial here instead of just deriving from MeshDepthMaterial,
    // due to a quirk in WebGLRenderer where it doesn't set the viewMatrix uniform
    // for MeshDepthMaterial, which is needed by the instancing upgrades.
    var shaderInfo = assign$1({}, three.ShaderLib.depth);
    shaderInfo.vertexShader = upgradeShaders(shaderInfo.vertexShader, '', []).vertexShader;
    var material = new three.ShaderMaterial(shaderInfo);
    material.isMeshDepthMaterial = true;
    material.depthPacking = three.RGBADepthPacking;
    getBatchDepthMaterial = function () { return material; };
    return material
  };

  var getBatchDistanceMaterial = function() {
    // We have to use a ShaderMaterial here instead of just deriving from MeshDistanceMaterial,
    // due to a quirk in WebGLRenderer where it doesn't set the viewMatrix uniform
    // for MeshDistanceMaterial, which is needed by the instancing upgrades.
    // Additionally, the way WebGLShadowMap rotates a single camera 6 times per object prevents
    // WebGLRenderer.setProgram() from updating the viewMatrix uniform for directions 2-6. To
    // get around this we define a ShaderMaterial uniform for it and monkeypatch in way to
    // intercept view changes and manually update the uniform to match (see modelViewMatrix
    // override above when constructing the batchObject).
    var shaderInfo = assign$1({}, three.ShaderLib.distanceRGBA);
    var viewMatrix = new three.Matrix4();
    shaderInfo.vertexShader = upgradeShaders(shaderInfo.vertexShader, '', []).vertexShader;
    shaderInfo.uniforms = assign$1({viewMatrix: {value: viewMatrix}}, shaderInfo.uniforms);
    var material = new three.ShaderMaterial(shaderInfo);
    material.isMeshDistanceMaterial = true;
    material.referencePosition = new three.Vector3(); //mutated during shadowmap setup
    material._updateViewMatrix = function (source) {
      viewMatrix.copy(source);
      material.uniformsNeedUpdate = true; //undocumented flag for ShaderMaterial
    };
    getBatchDistanceMaterial = function () { return material; };
    return material
  };

  var LIGHT_TYPES = {
    ambient: AmbientLight3DFacade,
    directional: DirectionalLight3DFacade,
    spot: SpotLight3DFacade,
    point: PointLight3DFacade
  };

  var RAY_INTERSECTION = [{distance: Infinity}];
  var INFINITE_SPHERE = new three.Sphere(undefined, Infinity);

  var Scene3DFacade = /*@__PURE__*/(function (Object3DFacade) {
    function Scene3DFacade(parent) {
      var scene = new three.Scene();
      // We always manually update world matrices when needed - see Object3DFacade.updateMatrices() -
      // so the additional autoUpdate pass done by threejs before render is not needed:
      scene.autoUpdate = false;
      Object3DFacade.call(this, parent, scene);
    }

    if ( Object3DFacade ) Scene3DFacade.__proto__ = Object3DFacade;
    Scene3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
    Scene3DFacade.prototype.constructor = Scene3DFacade;

    var prototypeAccessors = { fog: { configurable: true } };

    Scene3DFacade.prototype.afterUpdate = function afterUpdate () {
      var children = {
        key: 'instancingMgr',
        facade: InstancingManager,
        children: this.objects
      };

      // Map light definitions to their appropriate classes
      if (this.lights && this.lights.length) {
        var lights = this.lights.map(function (def, i) {
          var realDef = troikaCore.utils.assign({}, def);
          delete realDef.type;
          realDef.key = "$$$light_" + i;
          realDef.facade = realDef.facade || LIGHT_TYPES[def.type];
          return realDef.facade ? realDef : null
        });
        children = lights.concat(children);
      }
      this.children = children;

      Object3DFacade.prototype.afterUpdate.call(this);
    };

    prototypeAccessors.fog.set = function (def) {
      var fogObj = this._fogObj;
      if (def) {
        var isExp2 = 'density' in def;
        var fogClass = isExp2 ? three.FogExp2 : three.Fog;
        if (!fogObj || !(fogObj instanceof fogClass)) {
          fogObj = this._fogObj = new fogClass();
        }
        fogObj.color.set(def.color);
        if (isExp2) {
          fogObj.density = def.density;
        } else {
          fogObj.near = def.near;
          fogObj.far = def.far;
        }
      } else {
        fogObj = this._fogObj = null;
      }
      this.threeObject.fog = fogObj;
    };

    Scene3DFacade.prototype.getBoundingSphere = function getBoundingSphere () {
      return INFINITE_SPHERE
    };

    Scene3DFacade.prototype.raycast = function raycast (raycaster) {
      // Scene3DFacade will always intersect, but as the furthest from the camera
      return RAY_INTERSECTION
    };

    Object.defineProperties( Scene3DFacade.prototype, prototypeAccessors );

    return Scene3DFacade;
  }(Object3DFacade));

  var assign$2 = troikaCore.utils.assign;
  var forOwn$1 = troikaCore.utils.forOwn;
  var tempSphere = new three.Sphere();
  var SQRT3 = Math.sqrt(3);



  var BoundingSphereOctree = function BoundingSphereOctree() {
    this.root = null;
    this.keysToLeaves = Object.create(null);
  };

  BoundingSphereOctree.prototype.putSpheres = function putSpheres (spheres) {
      var this$1 = this;

    forOwn$1(spheres, function (sphere, key) {
      this$1.putSphere(key, sphere);
    });
  };

  BoundingSphereOctree.prototype.putSphere = function putSphere (key, sphere) {
      var this$1 = this;

    var center = sphere.center;
      var radius = sphere.radius;
    var root = this.root;

    // Sanity check
    if (!sphere || isNaN(radius) || isNaN(center.x)) {
      console.warn('Invalid sphere', sphere);
      return
    }

    // If we already have a sphere for this key, perform an update
    if (key in this.keysToLeaves) {
      return this._updateSphere(key, sphere)
    }

    // First sphere being added: create a leaf octant and set it as the root. This will be replaced as
    // soon as a second item is added, so we can start with an initial root bounding cube that matches
    // our actual dataset rather than an arbitrary one.
    if (!root) {
      var newRoot = new Octant();
      newRoot.isLeaf = true;
      newRoot.addSphereData(key, sphere);
      this.root = newRoot;
      this.keysToLeaves[key] = newRoot;
    }

    // Second sphere being added:
    else if (root.isLeaf) {
      var oldRoot = this.root;
      var dataX = root.dataX;
        var dataY = root.dataY;
        var dataZ = root.dataZ;

      // Handle special case where the second sphere has the same center point as the first, we still
      // can't determine good starting bounds so just append to the existing leaf
      if (dataX === center.x && dataY === center.y && dataZ === center.z) {
        this._insertIntoOctant(key, sphere, root);
      }
      // Non-coincident: we can now choose an appropriate size for the root node's box. Overwrite the
      // root with a new branch octant, and set its position/size to the smallest whole-integer cube
      // that contains both sphere centerpoints. (Cube rounded to whole ints to avoid floating point issues)
      else {
        var newRoot$1 = new Octant();
        var cx = newRoot$1.cx = Math.round((dataX + center.x) / 2);
        var cy = newRoot$1.cy = Math.round((dataY + center.y) / 2);
        var cz = newRoot$1.cz = Math.round((dataZ + center.z) / 2);
        newRoot$1.cr = Math.ceil(Math.max(Math.abs(cx - dataX), Math.abs(cy - dataY), Math.abs(cz - dataZ)) + 1e-5);
        this.root = newRoot$1;

        // Re-add the original leaf's sphere(s) and the new sphere under the new branch root, and exit
        oldRoot.forEachLeafSphere(function (_sphere, _key) { return this$1._insertIntoOctant(_key, _sphere, newRoot$1); });
        this._insertIntoOctant(key, sphere, newRoot$1);
      }
    }

    // Expand the root to cover the new centerpoint if necessary, and insert the sphere within it
    else {
      this._expandToCoverPoint(center.x, center.y, center.z);
      this._insertIntoOctant(key, sphere, this.root);
    }
  };

  BoundingSphereOctree.prototype._expandToCoverPoint = function _expandToCoverPoint (x, y, z) {
    // Loop until the root cube contains the new point...
    while (!this.root.containsPoint(x, y, z)) {
      // Create a larger branch, expanded by 2x in the corner direction closest to the new point
      var oldRoot = this.root;
      var cx = oldRoot.cx;
        var cy = oldRoot.cy;
        var cz = oldRoot.cz;
        var cr = oldRoot.cr;
      var newRoot = new Octant();
      newRoot.maxRadius = oldRoot.maxRadius;
      newRoot.sphereCount = oldRoot.sphereCount;
      newRoot.leafCount = oldRoot.leafCount;

      newRoot.cx = cx + cr * (x < cx ? -1 : 1);
      newRoot.cy = cy + cr * (y < cy ? -1 : 1);
      newRoot.cz = cz + cr * (z < cz ? -1 : 1);
      newRoot.cr = cr * 2;

      // Move the old root to be a child of the new outer box, and make the outer box the new root
      var octantIdx = newRoot.getSubOctantIndexForPoint(cx, cy, cz);
      oldRoot.parent = newRoot;
      oldRoot.index = octantIdx;
      newRoot[octantIdx] = oldRoot;
      this.root = newRoot;
    }
  };

  BoundingSphereOctree.prototype._insertIntoOctant = function _insertIntoOctant (key, sphere, octant) {
    var center = sphere.center;
      var radius = sphere.radius;

    // If the parent octant is a leaf:
    if (octant.isLeaf) {
      var dataX = octant.dataX;
        var dataY = octant.dataY;
        var dataZ = octant.dataZ;

      // If the new sphere's center matches that of the leaf, add it to the leaf's members
      if (center.x === dataX && center.y === dataY && center.z === dataZ) {
        octant.addSphereData(key, sphere);

        // Increase maxRadius up the parent tree as needed
        for (var oct = octant.parent; oct; oct = oct.parent) {
          if (radius > oct.maxRadius) { oct.maxRadius = radius; }
        }

        // Add to index
        this.keysToLeaves[key] =octant;
      }

      // Otherwise split the leaf into a branch, push the old leaf down, and try again
      else {
        var newBranch = _createBranchFromLeaf(octant);
        octant.parent[octant.index] = newBranch;
        newBranch.addOctantForPoint(octant, dataX, dataY, dataZ);
        this._insertIntoOctant(key, sphere, newBranch); //recurse
      }
    }

    // The parent octant is a branch:
    else {
      // Always increment branch's total count
      octant.sphereCount++;

      // Find the suboctant index in which the new center point falls
      var subOctantIndex = octant.getSubOctantIndexForPoint(center.x, center.y, center.z);

      // If there is nothing at that index yet, insert a new leaf octant
      var subOctant = octant[subOctantIndex];
      if (!subOctant) {
        var newLeaf = new Octant();
        newLeaf.isLeaf = true;
        octant.addOctantForPoint(newLeaf, center.x, center.y, center.z);
        newLeaf.addSphereData(key, sphere);

        // Increment leafCount and maxRadius up the parent tree
        for (var oct$1 = newLeaf.parent; oct$1; oct$1 = oct$1.parent) {
          if (radius > oct$1.maxRadius) { oct$1.maxRadius = radius; }
          oct$1.leafCount++;
        }

        // Add to index
        this.keysToLeaves[key] = newLeaf;
      }

      // If there was already a sub-octant at that index, recurse
      else {
        return this._insertIntoOctant(key, sphere, subOctant)
      }
    }
  };

  BoundingSphereOctree.prototype.removeSphere = function removeSphere (key) {
    // Find the existing leaf that holds the sphere
    var leafOctant = this.keysToLeaves[key];
    if (!leafOctant) { return }

    // Preemptively decrement sphereCount up the parent tree
    var oct = leafOctant.parent;
    while (oct) {
      oct.sphereCount--;
      oct = oct.parent;
    }

    // If there are other members in the leaf, remove it from the leaf's members and keep the leaf in place
    if (leafOctant.sphereCount > 1) {
      // Remove sphere from the leaf data
      leafOctant.removeSphereData(key);

      // Update maxRadius up the tree
      leafOctant.updateMaxRadii();
    }

    // It was the only member of the leaf; remove the leaf and any ancestor branches that are now empty
    else {
      // Walk up the tree and remove all empty branches
      oct = leafOctant;
      var lowestRemainingOctant;
      do {
        var parent = oct.parent;
        lowestRemainingOctant = parent;
        if (parent) {
          parent[oct.index] = null;
        }
        oct = oct.parent;
      } while (oct && oct.sphereCount === 0)

      // If we got to the top of the tree, it's totally empty so set the root to null and exit
      if (!lowestRemainingOctant) {
        this.root = null;
        return
      }

      // Continue up the tree, decrementing the leafCount and looking for the highest branch point with only
      // a single remaining leaf underneath it, if any
      var highestSingleLeafBranch = null;
      oct = lowestRemainingOctant;
      while (oct) {
        oct.leafCount--;
        if (oct.leafCount === 1) {
          highestSingleLeafBranch = oct;
        }
        oct = oct.parent;
      }

      // If we were left with a branch with only one leaf descendant, move that leaf up to the branch point
      if (highestSingleLeafBranch) {
        var leaf = this._findSingleLeaf(highestSingleLeafBranch);
        var parent$1 = highestSingleLeafBranch.parent;
        if (parent$1) {
          parent$1.addOctantForPoint(leaf, leaf.cx, leaf.cy, leaf.cz);
          parent$1.updateMaxRadii();
        } else {
          this.root = leaf;
        }
      } else {
        // Update the max radii up the tree from the lowest remaining node
        lowestRemainingOctant.updateMaxRadii();
      }
    }

    // Delete it from the index
    delete this.keysToLeaves[key];
  };

  BoundingSphereOctree.prototype._updateSphere = function _updateSphere (key, sphere) {
    // Find the existing leaf octant that holds the sphere
    var leaf = this.keysToLeaves[key];

    var center = sphere.center;

    // If its center point still falls within the leaf's cube, we can fast-path the changes:
    if (leaf.containsPoint(center.x, center.y, center.z)) {
      var isMulti = leaf.sphereCount > 1;
      var hasMoved = center.x !== leaf.dataX ||
        center.y !== leaf.dataY ||
        center.z !== leaf.dataZ;

      // If it was not the only member and has changed position, split that leaf; we can do this
      // slightly faster than a full remove+add because we know this will be the branch point and can
      // avoid some unnecessary upward tree walking
      if (isMulti && hasMoved) {
        leaf.removeSphereData(key);
        leaf.updateMaxRadii();
        this._insertIntoOctant(key, sphere, leaf);
      }

      // Otherwise we can just update this leaf
      else {
        if (hasMoved) {
          leaf.dataX = center.x;
          leaf.dataY = center.y;
          leaf.dataZ = center.z;
        }
        if (sphere.radius !== leaf.maxRadius) {
          leaf.updateMaxRadii();
        }
      }
    }

    // If its center point is no longer within the leaf, delegate to full remove+add
    // TODO possible faster path: remove only up to lowest common ancestor branch point,
    // collapse remaining up to that point, and insert sphere under that point
    else {
      this.removeSphere(key);
      this.putSphere(key, sphere);
    }
  };

  // Optimized utility for finding single descendant leaf without creating a function
  BoundingSphereOctree.prototype._findSingleLeaf = function _findSingleLeaf (octant) {
    var leaf;
    function visit(oct) {
      if (oct.isLeaf) { leaf = oct; }
    }
    function find(oct) {
      leaf = null;
      this.walkBranch(oct, visit);
      return leaf
    }
    this._findSingleLeaf = find; //reuse closure after first call
    return find.call(this, octant)
  };


  /**
   * Perform a depth-first walk of the tree structure, invoking a `callback` function for
   * each node. The `callback` will be passed the current tree node object, and will be invoked
   * for parent branch nodes first before their child nodes.
   *
   * If the function returns `false` for a branch node, none of that branch's children will be
   * visited; this is how you can efficiently query the tree by filtering out the majority of branches.
   *
   * @param {Function} callback
   */
  BoundingSphereOctree.prototype.walkTree = function walkTree (callback) {
    if (this.root) {
      this.walkBranch(this.root, callback);
    }
  };
  BoundingSphereOctree.prototype.walkBranch = function walkBranch (root, callback) {
    if (callback(root) !== false && !root.isLeaf) {
      for (var i = 0; i < 8; i++) {
        if (root[i] !== null) {
          this.walkBranch(root[i], callback);
        }
      }
    }
  };


  /**
   * Given a {@link Ray}, search the octree for any spheres that intersect that ray and invoke
   * the given `callback` function, passing it the sphere and its key as arguments.
   * TODO need to handle near/far
   *
   * @param {Ray} ray
   * @param {Function} callback
   * @param {Object} scope
   */
  BoundingSphereOctree.prototype.forEachSphereOnRay = function forEachSphereOnRay (ray, callback, scope) {
    return this._forEachMatchingSphere(ray.intersectsSphere.bind(ray), callback, scope)
  };

  BoundingSphereOctree.prototype.forEachIntersectingSphere = function forEachIntersectingSphere (sphere, callback, scope) {
    return this._forEachMatchingSphere(sphere.intersectsSphere.bind(sphere), callback, scope)
  };

  BoundingSphereOctree.prototype._forEachMatchingSphere = function _forEachMatchingSphere (testFn, callback, scope) {
    // const startTime = performance.now()
    // let branchTests = 0
    // let sphereTests = 0
    // let sphereHits = 0

    function visitSphere(sphere, key) {
      // sphereTests++
      if (testFn(sphere)) {
        // sphereHits++
        callback.call(scope, sphere, key);
      }
    }

    this.walkTree(function (octant) {
      if (octant.isLeaf) { //leaf
        octant.forEachLeafSphere(visitSphere);
      } else { //branch
        // branchTests++
        // Test using a sphere large enough to cover the maximum constituent bounding sphere with
        // its center anywhere within the octant's box. This will obviously catch some false positives
        // but those will be filtered at the leaf level.
        // TODO investigate using a Box3 test, which could have fewer false positives, but only if that
        // outweighs its slower speed (see https://jsperf.com/ray-intersectsphere-vs-intersectbox)
        tempSphere.center.set(octant.cx, octant.cy, octant.cz);
        tempSphere.radius = octant.cr * SQRT3 + octant.maxRadius;
        if (!testFn(tempSphere)) {
          return false //ignore this branch
        }
      }
      return true
    });

    //console.log(`Raycast search: ${branchTests} branch tests, ${sphereTests} sphere tests, and ${sphereHits} hits, in ${performance.now() - startTime}ms`)
  };




  var Octant = function Octant () {};

  Octant.prototype.containsPoint = function containsPoint (x, y, z) {
    var ref = this;
      var cx = ref.cx;
      var cy = ref.cy;
      var cz = ref.cz;
      var cr = ref.cr;
    return x >= cx - cr && x < cx + cr &&
      y >= cy - cr && y < cy + cr &&
      z >= cz - cr && z < cz + cr
  };

  Octant.prototype.getSubOctantIndexForPoint = function getSubOctantIndexForPoint (x, y, z) {
    return (z < this.cz ? 0 : 4) + (y < this.cy ? 0 : 2) + (x < this.cx ? 0 : 1)
  };

  Octant.prototype.addOctantForPoint = function addOctantForPoint (subOctant, x, y, z) {
    var index = this.getSubOctantIndexForPoint(x, y, z);
    var subCR = this.cr / 2;

    subOctant.parent = this;
    subOctant.index = index;
    subOctant.cx = this.cx + subCR * (x < this.cx ? -1 : 1);
    subOctant.cy = this.cy + subCR * (y < this.cy ? -1 : 1);
    subOctant.cz = this.cz + subCR * (z < this.cz ? -1 : 1);
    subOctant.cr = subCR;

    this[index] = subOctant;
    return subOctant
  };

  Octant.prototype.findMaxSphereRadius = function findMaxSphereRadius () {
    var maxRadius = 0;
    if (this.isLeaf) {
      var data = this.data;
      if (this.sphereCount > 1) {
        for (var key in data) {
          var r = data[key].radius;
          if (r > maxRadius) { maxRadius = r; }
        }
      } else {
        maxRadius = data.radius;
      }
    } else {
      for (var i = 0; i < 8; i++) {
        if (this[i] !== null && this[i].maxRadius > maxRadius) {
          maxRadius = this[i].maxRadius;
        }
      }
    }
    return maxRadius
  };

  Octant.prototype.updateMaxRadii = function updateMaxRadii () {
    // Find the max maxRadius of the leaf octant's members
    var maxRadius = this.findMaxSphereRadius();

    // If the max radius has grown, just do a simple increase of the ancestor maxRadius values
    if (maxRadius > this.maxRadius) {
      var octant = this;
      while (octant) {
        if (maxRadius > octant.maxRadius) {
          octant.maxRadius = maxRadius;
        }
        octant = octant.parent;
      }
    }
    // If the max radius has shrunk, set it and repeat the process up the parent tree
    else if (maxRadius < this.maxRadius) {
      this.maxRadius = maxRadius;
      if (this.parent) {
        this.parent.updateMaxRadii();
      }
    }
  };

  Octant.prototype.addSphereData = function addSphereData (key, sphere) {
    var count = this.sphereCount++;
    if (count === 0) {
      this.leafCount = 1;
      this.data = sphere;
      this.dataKey = key;
      // copy center coords from the first added sphere
      var center = sphere.center;
      this.dataX = center.x;
      this.dataY = center.y;
      this.dataZ = center.z;
    }
    else if (count === 1) {
      var oldSphere = this.data;
      var newData = this.data = Object.create(null);
      newData[this.dataKey] = oldSphere;
      newData[key] = sphere;
      this.dataKey = null;
    }
    else if (count > 1) {
      this.data[key] = sphere;
    }

    if (sphere.radius > this.maxRadius) {
      this.maxRadius = sphere.radius;
    }
  };

  Octant.prototype.removeSphereData = function removeSphereData (key) {
    var data = this.data;
    if (data) {
      var count = this.sphereCount--;
      if (count > 2) {
        delete data[key];
      }
      else if (count === 2) {
        for (var _key in data) {
          if (_key !== key) {
            this.dataKey = _key;
            this.data = data[_key];
            break
          }
        }
      }
      else {
        this.data = null;
      }
    }
  };

  Octant.prototype.forEachLeafSphere = function forEachLeafSphere (fn, scope) {
    var data = this.data;
    if (data) {
      if (this.sphereCount > 1) {
        for (var key in data) {
          fn.call(scope, data[key], key);
        }
      } else {
        fn.call(scope, data, this.dataKey);
      }
    }
  };
  assign$2(Octant.prototype, {
    // Relationships
    parent: null,
    index: -1,

    // Cube bounds
    cx: 0, //center x
    cy: 0, //center y
    cz: 0, //center z
    cr: 0, //cubic radius (dist from center to edge)

    // Sub-octants
    0: null,
    1: null,
    2: null,
    3: null,
    4: null,
    5: null,
    6: null,
    7: null,

    // Leaf data
    // For a single-item leaf (probably the vast majority) `data` will be the Sphere object and `dataKey`
    // will be its key. For a multi-item leaf, `data` will be an object of key->Sphere mappings and
    // `dataKey` will be null. I'm not a huge fan of the asymmetry but this lets us avoid an extra
    // sub-object for the majority of leaves while keeping the Octant's shape predictable for the JS engine.
    isLeaf: false,
    data: null,
    dataKey: null,
    // The first sphere added to the leaf will have its center position copied for easier access and
    // to avoid issues with the Sphere objects being mutated elsewhere.
    dataX: 0,
    dataY: 0,
    dataZ: 0,

    // Stats
    sphereCount: 0,
    leafCount: 0,
    maxRadius: 0
  });



  var _createBranchFromLeaf = (function() {
    var copyProps = ['parent', 'index', 'cx', 'cy', 'cz', 'cr', 'sphereCount', 'leafCount', 'maxRadius'];
    return function(leaf) {
      var branch = new Octant();
      for (var i = copyProps.length; i--;) {
        branch[copyProps[i]] = leaf[copyProps[i]];
      }
      return branch
    }
  })();

  var assign$3 = troikaCore.utils.assign;
  var assignIf$1 = troikaCore.utils.assignIf;
  var tmpVec2 = new three.Vector2();
  var tmpVec3 = new three.Vector3();
  var raycaster = new three.Raycaster();


  var World3DFacade = /*@__PURE__*/(function (WorldBaseFacade) {
    function World3DFacade(canvas) {
      WorldBaseFacade.call(this, canvas);
      this._object3DFacadesById = Object.create(null);
      this._onBgClick = this._onBgClick.bind(this);
    }

    if ( WorldBaseFacade ) World3DFacade.__proto__ = WorldBaseFacade;
    World3DFacade.prototype = Object.create( WorldBaseFacade && WorldBaseFacade.prototype );
    World3DFacade.prototype.constructor = World3DFacade;

    World3DFacade.prototype.afterUpdate = function afterUpdate () {
      var ref = this;
      var width = ref.width;
      var height = ref.height;
      var antialias = ref.antialias;
      var backgroundColor = ref.backgroundColor;
      var contextAttributes = ref.contextAttributes;
      var canvas = ref._element;

      // Set up renderer
      var renderer = this._threeRenderer;
      var RendererClass = this.rendererClass || three.WebGLRenderer;
      if (!renderer || !(renderer instanceof RendererClass)) {
        if (renderer) {
          renderer.dispose();
        }
        // Init the context manually so we can prefer webgl2
        contextAttributes = assign$3({
          alpha: true,
          antialias: antialias
        }, contextAttributes);
        var context = canvas.getContext('webgl2', contextAttributes) || undefined;
        if (!context) {
          console.info('webgl2 init failed, trying webgl');
        }
        renderer = this._threeRenderer = new RendererClass(assign$3({
          canvas: canvas,
          context: context
        }, contextAttributes));
      }

      var shadows = this.shadows;
      renderer.shadowMap.enabled = !!shadows;
      if (shadows && typeof shadows === 'object') {
        assign$3(renderer.shadowMap, shadows);
      }

      if (backgroundColor !== this._bgColor) {
        this._threeRenderer.setClearColor(new three.Color(backgroundColor || 0), backgroundColor != null ? 1 : 0);
        this._bgColor = backgroundColor;
      }

      this.children = [
        this._getCameraDef(),
        this._getSceneDef()
      ];

      // Update render canvas size
      this._updateDrawingBufferSize(width, height, this.pixelRatio || window.devicePixelRatio || 1);

      WorldBaseFacade.prototype.afterUpdate.call(this);
    };

    /**
     * Build a normalized definition for the camera facade
     * @protected
     */
    World3DFacade.prototype._getCameraDef = function _getCameraDef () {
      var ref = this;
      var camera = ref.camera;
      return assign$3({
        key: 'camera',
        facade: PerspectiveCamera3DFacade,
        aspect: this.width / this.height
      }, camera)
    };

    /**
     * Build a normalized definition for the scene facade
     * @protected
     */
    World3DFacade.prototype._getSceneDef = function _getSceneDef () {
      return {
        key: 'scene',
        facade: Scene3DFacade,
        lights: this.lights,
        objects: this.objects,
        fog: this.fog,
        onClick: this.onBackgroundClick ? this._onBgClick : null
      }
    };

    /**
     * Update the renderer's drawing buffer size
     * @protected
     */
    World3DFacade.prototype._updateDrawingBufferSize = function _updateDrawingBufferSize (width, height, pixelRatio) {
      var renderer = this._threeRenderer;
      renderer.getSize(tmpVec2);
      if (tmpVec2.width !== width || tmpVec2.height !== height || renderer.getPixelRatio() !== pixelRatio) {
        renderer.setDrawingBufferSize(width, height, pixelRatio);
      }
    };

    World3DFacade.prototype.doRender = function doRender (/*...frameArgs*/) {
      var sceneFacade = this.getChildByKey('scene');
      var scene = sceneFacade.threeObject;
      var camera = this.getChildByKey('camera').threeObject;
      var renderer = this._threeRenderer;

      // Invoke any onBeforeRender listeners
      var registry = this.eventRegistry;
      function invokeHandler(handler, facadeId) {
        handler.call(this._object3DFacadesById[facadeId], renderer, scene, camera);
      }
      registry.forEachListenerOfType('beforerender', invokeHandler, this);

      // Render scene
      renderer.render(scene, camera);

      // Invoke any onAfterRender listeners
      registry.forEachListenerOfType('afterrender', invokeHandler, this);

      var onStatsUpdate = this.onStatsUpdate;
      if (onStatsUpdate) {
        var ref = renderer.info;
        var memory = ref.memory;
        var render = ref.render;
        var stats = {
          'WebGL Draw Calls': render.calls,
          'WebGL Geometries': memory.geometries,
          'WebGL Textures': memory.textures,
          'WebGL Triangles': render.triangles
        };
        if (render.points) {
          stats['WebGL Points'] = render.points;
        }
        if (render.lines) {
          stats['WebGL Lines'] = render.lines;
        }
        onStatsUpdate(stats);
      }
    };

    /**
     * Implementation of abstract
     */
    World3DFacade.prototype.getFacadeUserSpaceXYZ = function getFacadeUserSpaceXYZ (facade) {
      var matrixEls = facade.threeObject.matrixWorld.elements;
      return this.projectWorldPosition(matrixEls[12], matrixEls[13], matrixEls[14])
    };

    World3DFacade.prototype.projectWorldPosition = function projectWorldPosition (x, y, z) {
      tmpVec3.set(x, y, z);
      var camera = this.getChildByKey('camera');
      camera.updateMatrices();
      camera = camera.threeObject;

      // Make position relative to camera
      tmpVec3.applyMatrix4(camera.matrixWorldInverse);

      // Get relative distance to the point, negative if it's behind the camera
      var signedDistance = tmpVec3.length() * (tmpVec3.z > 0 ? -1 : 1);

      // Project x/y to screen coords
      tmpVec3.applyMatrix4(camera.projectionMatrix);
      var screenX = (tmpVec3.x + 1) * this.width / 2;
      var screenY = (1 - tmpVec3.y) * this.height / 2;

      return new three.Vector3(screenX, screenY, signedDistance)
    };

    /**
     * @override
     * In 3D worlds, we will normalize all pointer events so they always carry a `ray` property;
     * handlers for these events should then only rely on that, which is guaranteed to be present,
     * unlike `clientX/Y` etc. which are only present for pointer events originating from a screen.
     */
    World3DFacade.prototype._normalizePointerEvent = function _normalizePointerEvent (e) {
      // All pointer events in a 3D world will be given a `ray` property.
      if (!e.ray) {
        // normalize touch events
        var posInfo = e;
        if (e.touches) {
          var touches = /^touch(end|cancel)$/.test(e.type) ? e.changedTouches : e.touches;
          if (touches.length === 1) {
            posInfo = touches[0];
          }
        }

        // convert mouse position to normalized device coords (-1 to 1)
        var canvasRect = e.target.getBoundingClientRect(); //e.target is the canvas
        var width = canvasRect.width || this.width; //use logical size if no visible rect, e.g. offscreen canvas
        var height = canvasRect.height || this.height;
        var u = ((posInfo.clientX || 0) - (canvasRect.left || 0)) / width * 2 - 1;
        var v = ((posInfo.clientY || 0) - (canvasRect.top || 0)) / height * -2 + 1;

        // ensure camera's matrix is up to date
        var camera = this.getChildByKey('camera');
        camera.updateMatrices();

        // calculate the ray and put it on the event
        e.ray = camera.getRayAtProjectedCoords(u, v);
      }

      WorldBaseFacade.prototype._normalizePointerEvent.call(this, e);
    };

    /**
     * @override Implementation of abstract
     * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
     */
    World3DFacade.prototype.getFacadesAtEvent = function getFacadesAtEvent (e, filterFn) {
      return e.ray ? this.getFacadesOnRay(e.ray, filterFn) : null
    };

    World3DFacade.prototype.getFacadesOnRay = function getFacadesOnRay (ray, filterFn) {
      var this$1 = this;

      // update bounding sphere octree
      var octree = this._updateOctree();

      // search bounding sphere octree to quickly filter down to a small set of likely hits,
      // then do a true raycast on those facades
      var allHits = null;
      if (octree) {
        raycaster.ray = ray;
        octree.forEachSphereOnRay(ray, function (sphere, facadeId) {
          var facadesById = this$1._object3DFacadesById;
          var facade = facadesById && facadesById[facadeId];
          // let the filterFn eliminate things before trying to raycast them
          var hits = facade && (!filterFn || filterFn(facade)) && facade.raycast && facade.raycast(raycaster);
          if (hits && hits[0]) {
            // Ignore all but closest
            hits[0].facade = facade
            ;(allHits || (allHits = [])).push(hits[0]);
          }
        });
      }
      return allHits
    };

    World3DFacade.prototype._updateOctree = function _updateOctree () {
      // update octree with any new bounding spheres
      var octree = this._boundingSphereOctree;
      var changes = this._octreeChangeset;
      if (changes) {
        if (!octree) {
          octree = this._boundingSphereOctree = new BoundingSphereOctree();
        }
        var remove = changes.remove;
        var put = changes.put;
        if (remove) {
          for (var facadeId in remove) {
            octree.removeSphere(facadeId);
          }
        }
        if (put) {
          for (var facadeId$1 in put) {
            // Check for put requests for objects that are now obsolete
            var facade = this._object3DFacadesById[facadeId$1];
            if (facade && !facade.isDestroying && !(remove && remove[facadeId$1])) {
              var sphere = facade.getBoundingSphere && facade.getBoundingSphere();
              if (sphere) {
                octree.putSphere(facadeId$1, sphere);
              } else {
                octree.removeSphere(facadeId$1);
              }
            }
          }
        }
        this._octreeChangeset = null;
      }
      return octree
    };

    World3DFacade.prototype._queueForOctreeChange = function _queueForOctreeChange (changeType, facade) {
      var changes = this._octreeChangeset || (this._octreeChangeset = {});
      var map = changes[changeType] || (changes[changeType] = Object.create(null));
      map[facade.$facadeId] = facade;
    };

    World3DFacade.prototype._onBgClick = function _onBgClick (e) {
      // Ignore clicks that bubbled up
      if (e.target === e.currentTarget) {
        this.onBackgroundClick(e);
      }
    };

    World3DFacade.prototype.destructor = function destructor () {
      WorldBaseFacade.prototype.destructor.call(this);
      this._threeRenderer.dispose();
      this._threeRenderer.forceContextLoss();
    };

    return World3DFacade;
  }(troikaCore.WorldBaseFacade));



  World3DFacade.prototype._notifyWorldHandlers = assign$3(
    Object.create(troikaCore.WorldBaseFacade.prototype._notifyWorldHandlers),
    {
      getCameraPosition: function getCameraPosition(source, data) {
        // We decompose from the world matrix here to handle pose transforms on top of the configured position
        var camMatrix = this.getChildByKey('camera').threeObject.matrixWorld.elements;
        var position = new three.Vector3(camMatrix[12], camMatrix[13], camMatrix[14]);
        data.callback(position);
      },
      getCameraFacade: function getCameraFacade(source, data) {
        data.callback(this.getChildByKey('camera'));
      },
      getSceneFacade: function getSceneFacade(source, data) {
        data.callback(this.getChildByKey('scene'));
      },
      projectWorldPosition: function projectWorldPosition(source, data) {
        var pos = data.worldPosition;
        data.callback(this.projectWorldPosition(pos.x, pos.y, pos.z));
      },
      object3DAdded: function object3DAdded(source) {
        this._object3DFacadesById[source.$facadeId] = source;
        this._queueForOctreeChange('put', source);
      },
      object3DBoundsChanged: function object3DBoundsChanged(source) {
        this._queueForOctreeChange('put', source);
      },
      object3DRemoved: function object3DRemoved(source) {
        delete this._object3DFacadesById[source.$facadeId];
        this._queueForOctreeChange('remove', source);
      },
      rayPointerMotion: function rayPointerMotion(source, ray) {
        // Dispatch a custom event carrying the Ray, which will be used by our `getFacadesAtEvent`
        // override to search for a hovered facade
        var e = new MouseEvent('mousemove');
        e.isRayEvent = true;
        e.ray = ray;
        e.eventSource = source; //for tracking gesture states per ray source
        this._onPointerMotionEvent(e);
      },
      rayPointerAction: function rayPointerAction(source, eventParams) {
        // Dispatch a custom event carrying the Ray, which will be used by our `getFacadesAtEvent`
        // override to search for a hovered facade
        var e = new (eventParams.type === 'wheel' ? WheelEvent : MouseEvent)(eventParams.type, eventParams);
        e.isRayEvent = true;
        e.ray = eventParams.ray;
        e.eventSource = source; //for tracking gesture states per ray source
        this._onPointerActionEvent(e);
      }
    }
  );

  var refireableEvents = [
    'onMouseOver',
    'onMouseOut',
    'onMouseMove',
    'onMouseDown',
    'onMouseUp',
    'onClick',
    'onDoubleClick'
  ];


  /**
   * Create and return a higher-order facade class for a given facade class, that can render a
   * Troika sub-world (2D or 3D) into a Three.js `Texture` and supply that texture to
   * the facade. It can then be used by the facade for its own purposes, such as rendering
   * onto a 3D mesh.
   *
   * Pointer events will also be refired within the sub-world at the appropriate coordinates,
   * making the texture's contents interactive. This allows things like presenting a 2D user
   * interface that is mapped onto a 3D mesh.
   *
   * To configure the sub-world, define a `textureWorld` object on the facade's config. It
   * will work like any other facade config, and you'll need to set its `facade` property
   * to use either `World2DFacade` or `World3DFacade` as appropriate.
   *
   * @param {Facade} WrappedFacadeClass
   * @return {Facade}
   */
  function makeWorldTextureProvider(WrappedFacadeClass) {

    return /*@__PURE__*/(function (WrappedFacadeClass) {
      function WorldTextureProvider(parent) {
        var this$1 = this;

        var texture = new three.CanvasTexture(); //no canvas yet, will be added in first afterUpdate()
        WrappedFacadeClass.call(this, parent, texture);
        this.worldTexture = texture;

        // Wrap pointer events to both work as normal outer world events and also refire
        // in the inner world at their point on the surface texture
        var refire = this._refireAsInnerEvent.bind(this);
        refireableEvents.forEach(function (prop) {
          var userFn;
          function wrapperFn(e) {
            refire(e);
            if (userFn) { userFn.call(this, e); }
          }

          // trigger initial registration of event handler
          this$1[prop] = wrapperFn;

          // overwrite setter to just update the user-set function, and the getter
          // to always return the whole wrapper
          Object.defineProperty(this$1, prop, {
            set: function set(val) {
              userFn = val;
            },
            get: function get() {
              return wrapperFn
            }
          });
        });
      }

      if ( WrappedFacadeClass ) WorldTextureProvider.__proto__ = WrappedFacadeClass;
      WorldTextureProvider.prototype = Object.create( WrappedFacadeClass && WrappedFacadeClass.prototype );
      WorldTextureProvider.prototype.constructor = WorldTextureProvider;

      WorldTextureProvider.prototype.afterUpdate = function afterUpdate () {
        var this$1 = this;

        // Init the inner world if needed
        var innerWorld = this._worldFacade;
        var newWorldConfig = this.textureWorld;
        if (!innerWorld || !newWorldConfig || !(innerWorld instanceof newWorldConfig.facade)) {
          if (innerWorld) {
            innerWorld.onAfterRender = null;
            innerWorld.destructor();
          }
          if (newWorldConfig) {
            // Replace the old canvas with a new one each time, since browsers will throw errors when
            // changing canvas context types/options
            this.worldTexture.dispose();
            var canvas = document.createElement('canvas');
            canvas.width = canvas.height = 2;
            this.worldTexture.image = canvas;

            innerWorld = this._worldFacade = new newWorldConfig.facade(canvas);

            // Trigger texture update whenever the inner world is rerendered
            innerWorld.onAfterRender = function () {
              this$1.worldTexture.needsUpdate = true;
              this$1.notifyWorld('needsRender');
            };
          }
        }

        // Update the inner world
        if (innerWorld) {
          innerWorld.renderingScheduler = this._getOuterWorld().renderingScheduler;
          troikaCore.utils.assign(innerWorld, newWorldConfig);
          innerWorld.afterUpdate();
        }

        WrappedFacadeClass.prototype.afterUpdate.call(this);
      };

      WorldTextureProvider.prototype._refireAsInnerEvent = function _refireAsInnerEvent (e) {
        var world = this._worldFacade;
        if (world) {
          var uv = e.intersection && e.intersection.uv;
          var x = uv ? Math.round(uv.x * world.width) : -1;
          var y = uv ? Math.round((1 - uv.y) * world.height) : -1;

          var nativeEvent = e.nativeEvent || e;
          var innerEvent = document.createEvent('MouseEvents');
          innerEvent.initMouseEvent(
            nativeEvent.type, true, true, window, nativeEvent.detail, x, y, x, y, nativeEvent.ctrlKey,
            nativeEvent.altKey, nativeEvent.shiftKey, nativeEvent.metaKey, nativeEvent.button, null
          );
          this.worldTexture.image.dispatchEvent(innerEvent);
        }
      };

      WorldTextureProvider.prototype._getOuterWorld = function _getOuterWorld () {
        var outerWorld = this;
        while(outerWorld && !outerWorld.isWorld) {
          outerWorld = outerWorld.parent;
        }
        return outerWorld
      };

      WorldTextureProvider.prototype.destructor = function destructor () {
        var world = this._worldFacade;
        if (world) {
          world.onAfterRender = null;
          world.destructor();
        }
        this.worldTexture.dispose();
        WrappedFacadeClass.prototype.destructor.call(this);
      };

      return WorldTextureProvider;
    }(WrappedFacadeClass))

  }

  /**
   * Instanceable3DFacade is a specialized Object3DFacade that renders using GPU
   * instancing. This can give a significant performance boost for objects that
   * are rendered many thousands of times in a scene.
   *
   * Usage is nearly identical to an Object3DFacade, but instead of creating a
   * `threeObject` in the constructor, you set its `instancedThreeObject` property
   * to a common shared Mesh object. Any other Instanceable3DFacades in the scene
   * that reference the same `instancedThreeObject` will be batched together and
   * rendered using a single GPU draw call. The `instancedThreeObject` can be
   * changed at any time, allowing dynamic appearance changes by swapping out the
   * referenced mesh or its geometry or material.
   *
   * == Per-instance values: ==
   *
   * By default, the instances will each be rendered using their own world matrix
   * transform, so they can be positioned/scaled/rotated independently as usual.
   *
   * It is also possible, with a little extra effort, to allow specific shader
   * uniforms such as colors to be varied per instance. This works with both custom
   * shader materials as well as the built-in materials.
   *
   * To enable per-instance uniforms:
   *
   *   1) Declare which uniforms should be instanced by setting an `instanceUniforms`
   *   property on the `instancedThreeObject`'s material to an array of uniform names:
   *
   *       `baseObj.material.instanceUniforms = ['diffuse', 'emissive']`
   *
   *   This typically only needs to be done once for each material. Note that for built-in
   *   materials, you must use the uniform names used internally by their shaders and
   *   not the more user-friendly material properties, for example use `'diffuse'` rather than
   *   `'color'` for controlling a `MeshBasicMaterial`'s color.
   *
   *   2) For each Instanceable3DFacade, use the `setInstanceUniform(name, value)`
   *   method to set that instance's values for the enabled uniforms:
   *
   *       `this.setInstanceUniform('diffuse', new Color(color))`
   *
   *   If an instance does not have a uniform value set this way, it will fall back to using
   *   the default value in the material's `uniforms` object.
   *
   * The uniform types that allow instancing are: `int`, `float`, `vec2`, `vec3`, and `vec4`.
   * Mapping from application value types such as `Vector2` or `Color` behaves similarly to
   * how three.js does it internally. More complex uniform types such as textures are not
   * instanceable.
   *
   * == Caveats: ==
   *
   * It is generally not recommended to use this technique on meshes that are semi-
   * transparent, as there is no guarantee that they will be drawn in back-to-front
   * order relative to the camera position.
   */
  var Instanceable3DFacade = /*@__PURE__*/(function (Object3DFacade) {
    function Instanceable3DFacade(parent) {
      var obj = new three.Object3D();

      // Trigger scene graph size optimizations
      obj.isRenderable = false;

      // Visibility change affects batching so listen for changes
      obj.$troikaVisible = obj.visible;
      Object.defineProperty(obj, 'visible', visibilityPropDef);

      Object3DFacade.call(this, parent, obj);

      this.notifyWorld('instanceableAdded');
    }

    if ( Object3DFacade ) Instanceable3DFacade.__proto__ = Object3DFacade;
    Instanceable3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
    Instanceable3DFacade.prototype.constructor = Instanceable3DFacade;

    var prototypeAccessors = { instancedThreeObject: { configurable: true } };

    /**
     * Sets the Mesh instance to use for batching this instance with others that
     * reference the same Mesh.
     */
    prototypeAccessors.instancedThreeObject.set = function (obj) {
      if (obj !== this._instancedThreeObject) {
        this._instancedThreeObject = obj;
        this.notifyWorld('instanceableChanged');
        this._boundsChanged = true;
      }
    };
    prototypeAccessors.instancedThreeObject.get = function () {
      return this._instancedThreeObject
    };

    /**
     * Sets this instance's value for a shader uniform. The uniform must also be declared
     * as instanceable by setting `material.instanceUniforms = ['uniformName']`.
     * @param {String} name
     * @param {Number|Vector2|Vector3|Vector4|Color} value
     */
    Instanceable3DFacade.prototype.setInstanceUniform = function setInstanceUniform (name, value) {
      var values = this._instanceUniforms || (this._instanceUniforms = Object.create(null));
      if (values[name] !== value) {
        values[name] = value;
        this.notifyWorld('instanceableUniformChanged', name);
      }
    };

    Instanceable3DFacade.prototype.updateMatrices = function updateMatrices () {
      var prevMatrixVersion = this._worldMatrixVersion;

      Object3DFacade.prototype.updateMatrices.call(this);

      // If the world matrix changed, we must notify the instancing manager
      if (this._worldMatrixVersion !== prevMatrixVersion && this.threeObject.$troikaVisible) {
        this.notifyWorld('instanceableMatrixChanged');
      }
    };

    Instanceable3DFacade.prototype.destructor = function destructor () {
      this.notifyWorld('instanceableRemoved');
      Object3DFacade.prototype.destructor.call(this);
    };

    // Custom bounding sphere calc
    Instanceable3DFacade.prototype.getGeometry = function getGeometry () {
      var instancedObj = this.instancedThreeObject;
      return instancedObj && instancedObj.geometry
    };

    // Custom raycasting based on current geometry and transform
    Instanceable3DFacade.prototype.raycast = function raycast (raycaster) {
      var ref = this;
      var instancedThreeObject = ref.instancedThreeObject;
      var threeObject = ref.threeObject;
      if (instancedThreeObject && threeObject) {
        var origMatrix = instancedThreeObject.matrixWorld;
        instancedThreeObject.matrixWorld = threeObject.matrixWorld;
        var result = this._raycastObject(instancedThreeObject, raycaster); //use optimized method
        instancedThreeObject.matrixWorld = origMatrix;
        return result
      }
      return null
    };

    Object.defineProperties( Instanceable3DFacade.prototype, prototypeAccessors );

    return Instanceable3DFacade;
  }(Object3DFacade));

  var visibilityPropDef = {
    set: function set(visible) {
      if (visible !== this.$troikaVisible) {
        this.$troikaVisible = visible;
        this.$facade.notifyWorld('instanceableChanged');
      }
    },
    get: function get() {
      return this.$troikaVisible
    }
  };

  // Predefine shape to facilitate JS engine optimization
  troikaCore.utils.assign(Instanceable3DFacade.prototype, {
    _lastInstancedMatrixVersion: -1,
    _instancedThreeObject: null
  });

  var Canvas3D = /*@__PURE__*/(function (ReactCanvasBase) {
    function Canvas3D(props) {
      var this$1 = this;

      ReactCanvasBase.call(this, props);
      this._onCanvasRef = function (canvas) {
        var fn = this$1.context.onCanvasRef;
        if (fn) { fn(canvas); }
        fn = this$1.props.onCanvasRef;
        if (fn) { fn(canvas); }
      };
    }

    if ( ReactCanvasBase ) Canvas3D.__proto__ = ReactCanvasBase;
    Canvas3D.prototype = Object.create( ReactCanvasBase && ReactCanvasBase.prototype );
    Canvas3D.prototype.constructor = Canvas3D;

    Canvas3D.prototype.render = function render () {
      var ref = this;
      var props = ref.props;
      var context = ref.context;
      return React.createElement(
        ReactCanvasBase,
        troikaCore.utils.assign({}, props, {
          onCanvasRef: this._onCanvasRef,
          canvasStyle: props.canvasStyle || context.canvasStyle,
          worldFacade: props.worldFacade || context.worldFacade || World3DFacade,
          worldProps: troikaCore.utils.assign(
            {
              antialias: props.antialias,
              rendererClass: props.rendererClass,
              backgroundColor: props.backgroundColor,
              shadows: props.shadows,
              camera: props.camera,
              lights: props.lights,
              objects: props.objects,
              fog: props.fog,
              onBackgroundClick: props.onBackgroundClick
            },
            context.worldProps,
            props.worldProps
          )
        }),
        props.children
      )
    };

    return Canvas3D;
  }(troikaCore.ReactCanvasBase));

  Canvas3D.displayName = 'Canvas3D';

  Canvas3D.propTypes = troikaCore.utils.assignIf(
    {
      backgroundColor: T.any,
      lights: T.array,
      camera: T.object,
      objects: T.oneOfType([T.array, T.object]).isRequired,
      antialias: T.bool,
      onBackgroundClick: T.func,
      rendererClass: T.func
    },
    troikaCore.ReactCanvasBase.commonPropTypes
  );

  /**
   * Ancestors React components may provide these context values to override
   * how the world is created, e.g. switching to a WebXR-aware world impl
   */
  Canvas3D.contextType = React.createContext({
    worldFacade: World3DFacade,
    worldProps: {},
    onCanvasRef: null,
    canvasStyle: null
  });

  Object.defineProperty(exports, 'Facade', {
    enumerable: true,
    get: function () {
      return troikaCore.Facade;
    }
  });
  Object.defineProperty(exports, 'ListFacade', {
    enumerable: true,
    get: function () {
      return troikaCore.ListFacade;
    }
  });
  Object.defineProperty(exports, 'ParentFacade', {
    enumerable: true,
    get: function () {
      return troikaCore.ParentFacade;
    }
  });
  Object.defineProperty(exports, 'createDerivedMaterial', {
    enumerable: true,
    get: function () {
      return troikaThreeUtils.createDerivedMaterial;
    }
  });
  exports.AmbientLight3DFacade = AmbientLight3DFacade;
  exports.Canvas3D = Canvas3D;
  exports.DirectionalLight3DFacade = DirectionalLight3DFacade;
  exports.Group3DFacade = Group3DFacade;
  exports.HtmlOverlay3DFacade = HtmlOverlay3DFacade;
  exports.Instanceable3DFacade = Instanceable3DFacade;
  exports.InstancingManager = InstancingManager;
  exports.Object3DFacade = Object3DFacade;
  exports.OrthographicCamera3DFacade = OrthographicCamera3DFacade;
  exports.PerspectiveCamera3DFacade = PerspectiveCamera3DFacade;
  exports.PointLight3DFacade = PointLight3DFacade;
  exports.Scene3DFacade = Scene3DFacade;
  exports.SpotLight3DFacade = SpotLight3DFacade;
  exports.World3DFacade = World3DFacade;
  exports.makeWorldTextureProvider = makeWorldTextureProvider;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
